---
ms.openlocfilehash: f8a035cf72e9aaa28084cf7e8e5cd0749b5653dc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050873"
---
# <a name="node-jwa-build-statushttpstravis-ciorgbrianloveswordsnode-jwa"></a>node-jwa [![版本状态](https://travis-ci.org/brianloveswords/node-jwa.svg?branch=master)](https://travis-ci.org/brianloveswords/node-jwa)

一个 [JSON Web 算法](http://tools.ietf.org/id/draft-ietf-jose-json-web-algorithms-08.html)实现，目前仅侧重于 [JSON Web 签名](http://self-issued.info/docs/draft-ietf-jose-json-web-signature.html)所需的算法。

此库支持 JWS 的所有必需、推荐和可选加密算法：

alg 参数值 | 数字签名或 MAC 算法
----------------|----------------------------
HS256 | 使用 SHA-256 哈希算法的 HMAC
HS384 | 使用 SHA-384 哈希算法的 HMAC
HS512 | 使用 SHA-512 哈希算法的 HMAC
RS256 | 使用 SHA-256 哈希算法的 RSASSA
RS384 | 使用 SHA-384 哈希算法的 RSASSA
RS512 | 使用 SHA-512 哈希算法的 RSASSA
PS256 | 使用 SHA-256 哈希算法的 RSASSA-PSS
PS384 | 使用 SHA-384 哈希算法的 RSASSA-PSS
PS512 | 使用 SHA-512 哈希算法的 RSASSA-PSS
ES256 | 使用 P-256 曲线和 SHA-256 哈希算法的 ECDSA
ES384 | 使用 P-384 曲线和 SHA-384 哈希算法的 ECDSA
ES512 | 使用 P-521 曲线和 SHA-512 哈希算法的 ECDSA
无 | 未包含数字签名或 MAC 值

请注意，PS* 仅适用于 Node 6.12+（不包括 7.x）。

# <a name="requirements"></a>要求

若要运行测试，需要最新版本的 OpenSSL。 OSX 附带的版本（OpenSSL 0.9.8r 2011 年 2 月 8 日）
2011) 不够新，因为它不完全支持 ECDSA 密钥。 你需要使用高于 1.0.0 的版本；我使用 OpenSSL 1.0.1c 2012 年 5 月 10 日的版本进行了测试。

# <a name="testing"></a>测试

若要运行测试，请执行以下命令

```bash
$ npm test
```

这将生成一组用于测试的密钥对。 如果要生成新的密钥对，请在再次运行 `npm test` 之前执行 `make clean`。

## <a name="methodology"></a>方法

我生成了 `openssl dgst -sign` 来测试 OpenSSL 签名 → JS 验证和 `openssl dgst -verify` 来测试 JS 签名 → OpenSSL 验证用于每个 RSA 和 ECDSA 算法。

# <a name="usage"></a>使用情况

## <a name="jwaalgorithm"></a>jwa(algorithm)

使用算法的 `sign` 和 `verify` 方法创建一个新的 `jwa` 对象。 可在上表中找到算法的有效值（`'HS256'`、`'HS384'` 等），这些值区分大小写。 传递无效的算法值将引发 `TypeError`。


## <a name="jwasigninput-secretorprivatekey"></a>jwa#sign(input, secretOrPrivateKey)

使用 HMAC 算法的机密或 RSA 和 ECDSA 算法的私钥对某些输入进行签名。

如果输入还不是字符串或缓冲区，则会对其调用 `JSON.stringify` 以尝试强制使其字符串化。

对于 HMAC 算法，`secretOrPrivateKey` 应为字符串或缓冲区。 对于 ECDSA 和 RSA，该值应是表示 PEM 编码私钥的字符串。

输出采用 [base64url](http://en.wikipedia.org/wiki/Base64#URL_applications) 格式。 这是为了方便起见，因为 JWS 需要采用此格式的签名。 如果应用程序需要其他格式的输出，[请提出问题](https://github.com/brianloveswords/node-jwa/issues)。 在此期间，可使用 [brianloveswords/base64url](https://github.com/brianloveswords/base64url) 对签名进行解码。

从 nodejs v0.11.8 开始，引入了 SPKAC 支持。 如果你的 nodeJs 版本满足条件，则可以传递对象 `{ key: '..', passphrase: '...' }`


## <a name="jwaverifyinput-signature-secretorpublickey"></a>jwa#verify(input, signature, secretOrPublicKey)

验证签名。 返回 `true` 或 `false`。

`signature` 应为 base64url 编码的字符串。

对于 HMAC 算法，`secretOrPublicKey` 应为字符串或缓冲区。 对于 ECDSA 和 RSA，该值应是表示 PEM 编码公钥的字符串。


# <a name="example"></a>示例

HMAC
```js
const jwa = require('jwa');

const hmac = jwa('HS256');
const input = 'super important stuff';
const secret = 'shhhhhh';

const signature = hmac.sign(input, secret);
hmac.verify(input, signature, secret) // === true
hmac.verify(input, signature, 'trickery!') // === false
```

使用密钥
```js
const fs = require('fs');
const jwa = require('jwa');
const privateKey = fs.readFileSync(__dirname + '/ecdsa-p521-private.pem');
const publicKey = fs.readFileSync(__dirname + '/ecdsa-p521-public.pem');

const ecdsa = jwa('ES512');
const input = 'very important stuff';

const signature = ecdsa.sign(input, privateKey);
ecdsa.verify(input, signature, publicKey) // === true
```
## <a name="license"></a>许可

MIT

```
Copyright (c) 2013 Brian J. Brennan

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```
