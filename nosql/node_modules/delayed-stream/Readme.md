---
ms.openlocfilehash: 21db9b7ec97b7028a031a18867aab00575b09850
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138052970"
---
# <a name="delayed-stream"></a>delayed-stream

缓冲流中的事件，直到可将其处理。

## <a name="installation"></a>安装

``` bash
npm install delayed-stream
```

## <a name="usage"></a>使用情况

以下示例展示如何编写将其响应延迟 1000 毫秒的 http echo 服务器。

``` javascript
var DelayedStream = require('delayed-stream');
var http = require('http');

http.createServer(function(req, res) {
  var delayed = DelayedStream.create(req);

  setTimeout(function() {
    res.writeHead(200);
    delayed.pipe(res);
  }, 1000);
});
```

如果不使用 `Stream#pipe`，你还可以调用 `delayedStream.resume()` 来手动释放缓冲的事件：

``` javascript
var delayed = DelayedStream.create(req);

setTimeout(function() {
  // Emit all buffered events and resume underlaying source
  delayed.resume();
}, 1000);
```

## <a name="implementation"></a>实现

为正确使用该元流，以下是你应了解的关于实现的信息。

### <a name="event-buffering--proxying"></a>事件缓冲/代理

劫持 `source` 流的所有事件都是通过覆盖 `source.emit` 方法来实现的。 在节点实现包罗万象的事件侦听器之前，这是唯一的方法。

但无论是否释放了 delayed-stream，delayed-stream 仍会继续发出它在 `source` 上捕获的所有事件。

创建后，delayed-stream 会捕获所有 `source` 事件并将其存储在内部的事件缓冲区中。 调用 `delayedStream.release()` 后，所有缓冲的事件都会在 `delayedStream` 上发出，并清除事件缓冲区。 之后，delayed-stream 仅用作底层源的代理。

### <a name="error-handling"></a>错误处理

`source` 上的错误事件像其他任何事件一样被缓冲/代理。
不过，`delayedStream.create` 会将无操作 `'error'` 侦听器附加到 `source`。 这样，你只需处理 `delayedStream` 对象上的错误，而不是两个。

### <a name="buffer-limits"></a>缓冲限制

delay-stream 提供了 `maxDataSize` 属性，可用于限制缓冲的数据量。 为避免不响应 `source.pause()` 的错误 `source` 流，默认情况下启用此功能。

## <a name="api"></a>API

### <a name="delayedstreamcreatesource-options"></a>DelayedStream.create(source, [options])

返回一个新的 `delayedStream`。 可用选项包括：

* `pauseStream`
* `maxDataSize`

可在下方找到这些属性的描述。

### <a name="delayedstreamsource"></a>delayedStream.source

该对象管理的 `source` 流。 如果你正在传递 `delayedStream`，并且仍想访问 `source` 对象的属性，这很有用。

### <a name="delayedstreampausestream--true"></a>delayedStream.pauseStream = true

调用 `DelayedStream.create()` 时是否暂停底层 `source`。 之后修改此属性无效。

### <a name="delayedstreammaxdatasize--1024--1024"></a>delayedStream.maxDataSize = 1024 * 1024

发出 `error` 之前要缓冲的数据量。

如果底层源正在发出 `Buffer` 对象，则 `maxDataSize` 指的是字节。

如果底层源正在发出 JavaScript 字符串，则大小指的是字符。

如果你知道自己正在执行的操作，可以将此属性设置为 `Infinity` 以禁用此功能。 你也可以在运行时修改此属性。

### <a name="delayedstreamdatasize--0"></a>delayedStream.dataSize = 0

目前为止缓冲的数据量。

### <a name="delayedstreamreadable"></a>delayedStream.readable

返回 `source.readable` 值的 ECMA5 getter。

### <a name="delayedstreamresume"></a>delayedStream.resume()

如果目前为止尚未释放 `delayedStream`，则调用 `delayedStream.release()`。

在任一情况下，都会调用 `source.resume()`。

### <a name="delayedstreampause"></a>delayedStream.pause()

调用 `source.pause()`。

### <a name="delayedstreampipedest"></a>delayedStream.pipe(dest)

调用 `delayedStream.resume()`，然后将参数代理到 `source.pipe`。

### <a name="delayedstreamrelease"></a>delayedStream.release()

发出并清除目前为止已缓冲的所有事件。 这不会恢复底层源，请改用 `delayedStream.resume()`。

## <a name="license"></a>许可

delayed-stream 根据 MIT 许可证获得许可。
