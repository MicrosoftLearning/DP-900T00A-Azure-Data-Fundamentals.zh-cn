---
ms.openlocfilehash: f9f95f626a5d55dca7937d56df8b3dd3b7040164
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050653"
---
# <a name="bl-bufferlist"></a>bl *(BufferList)*

[![生成状态](https://api.travis-ci.com/rvagg/bl.svg?branch=master)](https://travis-ci.com/rvagg/bl/)

Node.js 缓冲区列表收集器、读取器和流式传输器。

[![NPM](https://nodei.co/npm/bl.svg)](https://nodei.co/npm/bl/)

bl 是 Node 缓冲区集合的存储对象，使用主缓冲区可读 API 公开它们。 还可以用作双工流，因此你可以从发出缓冲区的流中收集缓冲区，并向使用它们的流发出缓冲区！

原始缓冲区保持不变，并且仅在必要时进行复制。 任何需要使用单个原始缓冲区的读取都将仅返回该缓冲区的切片（引用与原始缓冲区相同的内存）。 跨越缓冲区的读取根据需要执行串联并以透明方式返回结果。

```js
const { BufferList } = require('bl')

const bl = new BufferList()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append('hi')                     // bl will also accept & convert Strings
bl.append(Buffer.from('j'))
bl.append(Buffer.from([ 0x3, 0x4 ]))

console.log(bl.length) // 12

console.log(bl.slice(0, 10).toString('ascii')) // 'abcdefghij'
console.log(bl.slice(3, 10).toString('ascii')) // 'defghij'
console.log(bl.slice(3, 6).toString('ascii'))  // 'def'
console.log(bl.slice(3, 8).toString('ascii'))  // 'defgh'
console.log(bl.slice(5, 10).toString('ascii')) // 'fghij'

console.log(bl.indexOf('def')) // 3
console.log(bl.indexOf('asdf')) // -1

// or just use toString!
console.log(bl.toString())               // 'abcdefghij\u0003\u0004'
console.log(bl.toString('ascii', 3, 8))  // 'defgh'
console.log(bl.toString('ascii', 5, 10)) // 'fghij'

// other standard Buffer readables
console.log(bl.readUInt16BE(10)) // 0x0304
console.log(bl.readUInt16LE(10)) // 0x0403
```

在构造函数中给它一个回调，并像 [concat-stream](https://github.com/maxogden/node-concat-stream) 一样使用它：

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

fs.createReadStream('README.md')
  .pipe(BufferListStream((err, data) => { // note 'new' isn't strictly required
    // `data` is a complete Buffer object containing the full data
    console.log(data.toString())
  }))
```

请注意，使用回调方法时，生成的 `data` 参数是列表中所有 `Buffer` 对象的串联。 如果你想避免这种串联的开销（在极端性能意识的情况下），那么避免使用回调方法，而仅侦听 `'end'`，就像标准流一样。

或者，若要使用 [hyperquest](https://github.com/substack/hyperquest) 提取 URL（应该与 [request](http://github.com/mikeal/request) 甚至普通 Node http 一起使用！）：

```js
const hyperquest = require('hyperquest')
const { BufferListStream } = require('bl')

const url = 'https://raw.github.com/rvagg/bl/master/README.md'

hyperquest(url).pipe(BufferListStream((err, data) => {
  console.log(data.toString())
}))
```

或者，将其用作可读流，以将缓冲区列表重构为输出源：

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

var bl = new BufferListStream()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append(Buffer.from('hi'))
bl.append(Buffer.from('j'))

bl.pipe(fs.createWriteStream('gibberish.txt'))
```

## <a name="api"></a>API

  * <a href="#ctor"><code><b>new BufferList([ buf ])</b></code></a>
  * <a href="#isBufferList"><code><b>BufferList.isBufferList(obj)</b></code></a>
  * <a href="#length"><code>bl.<b>length</b></code></a>
  * <a href="#append"><code>bl.<b>append(buffer)</b></code></a>
  * <a href="#get"><code>bl.<b>get(index)</b></code></a>
  * <a href="#indexOf"><code>bl.<b>indexOf(value[, byteOffset][, encoding])</b></code></a>
  * <a href="#slice"><code>bl.<b>slice([ start[, end ] ])</b></code></a>
  * <a href="#shallowSlice"><code>bl.<b>shallowSlice([ start[, end ] ])</b></code></a>
  * <a href="#copy"><code>bl.<b>copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])</b></code></a>
  * <a href="#duplicate"><code>bl.<b>duplicate()</b></code></a>
  * <a href="#consume"><code>bl.<b>consume(bytes)</b></code></a>
  * <a href="#toString"><code>bl.<b>toString([encoding, [ start, [ end ]]])</b></code></a>
  * <a href="#readXX"><code>bl.<b>readDoubleBE()</b></code>, <code>bl.<b>readDoubleLE()</b></code>, <code>bl.<b>readFloatBE()</b></code>, <code>bl.<b>readFloatLE()</b></code>, <code>bl.<b>readInt32BE()</b></code>, <code>bl.<b>readInt32LE()</b></code>, <code>bl.<b>readUInt32BE()</b></code>, <code>bl.<b>readUInt32LE()</b></code>, <code>bl.<b>readInt16BE()</b></code>, <code>bl.<b>readInt16LE()</b></code>, <code>bl.<b>readUInt16BE()</b></code>, <code>bl.<b>readUInt16LE()</b></code>, <code>bl.<b>readInt8()</b></code>, <code>bl.<b>readUInt8()</b></code></a>
  * <a href="#ctorStream"><code><b>new BufferListStream([ callback ])</b></code></a>

--------------------------------------------------------
<a name="ctor"></a>
### <a name="new-bufferlist-buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferList([ Buffer | Buffer array | BufferList | BufferList array | String ])
构造函数不需要任何参数，但可以通过传入单个 `Buffer` 对象或 `Buffer` 对象数组来初始化列表。

`new` 并不是硬性要求，但如果不实例化新对象，它将自动为你完成，因此你可以简单地通过以下内容创建新实例：

```js
const { BufferList } = require('bl')
const bl = BufferList()

// equivalent to:

const { BufferList } = require('bl')
const bl = new BufferList()
```

--------------------------------------------------------
<a name="isBufferList"></a>
### <a name="bufferlistisbufferlistobj"></a>BufferList.isBufferList(obj)
确定传递的对象是否为 `BufferList`. 如果传递的对象是 `BufferList` 或 `BufferListStream` 的实例，则它将返回 `true`，否则返回 `false`。

N.B. 在添加此静态方法之前，由此库的版本创建的 `BufferList` 或 `BufferListStream` 实例不会返回 `true`。

--------------------------------------------------------
<a name="length"></a>
### <a name="bllength"></a>bl.length
获取列表的长度（以字节为单位）。 此值是列表中包含的所有缓冲区的长度之和减去开始时半消耗缓冲区的任何初始偏移量得到的。 应准确表示可从列表中读取的字节总数。

--------------------------------------------------------
<a name="append"></a>
### <a name="blappendbuffer--buffer-array--bufferlist--bufferlist-array--string"></a>bl.append(Buffer | Buffer array | BufferList | BufferList array | String)
`append(buffer)` 向内部列表添加其他缓冲区或 BufferList。 已返回 `this`，因此可以链接它。

--------------------------------------------------------
<a name="get"></a>
### <a name="blgetindex"></a>bl.get(index)
`get()` 返回指定索引处的字节。

--------------------------------------------------------
<a name="indexOf"></a>
### <a name="blindexofvalue-byteoffset-encoding"></a>bl.indexOf(value[, byteOffset][, encoding])
`get()` 返回指定索引处的字节。
`indexOf()` 方法返回可在 BufferList 中找到给定元素的第一个索引，如果不存在，则返回 -1。

--------------------------------------------------------
<a name="slice"></a>
### <a name="blslice-start--end--"></a>bl.slice([ start, [ end ] ])
`slice()` 返回一个新的 `Buffer` 对象，其中包含指定范围内的字节。 `start` 和 `end` 都是可选的，将分别默认为列表的开头和结尾。

如果请求的范围跨越单个内部缓冲区，则将返回该缓冲区的切片，该切片共享该缓冲区的原始内存范围。 如果范围跨越多个缓冲区，则可能会发生复制操作，以便提供统一缓冲区。

--------------------------------------------------------
<a name="shallowSlice"></a>
### <a name="blshallowslice-start--end--"></a>bl.shallowSlice([ start, [ end ] ])
`shallowSlice()` 返回一个新的 `BufferList` 对象，其中包含指定范围内的字节。 `start` 和 `end` 都是可选的，将分别默认为列表的开头和结尾。

不会执行任何副本。 结果中的所有缓冲区与原始列表共享内存。

--------------------------------------------------------
<a name="copy"></a>
### <a name="blcopydest--deststart--srcstart--srcend---"></a>bl.copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])
`copy()` 复制 `dest` 缓冲区中的列表内容，从 `destStart` 开始，包含 `srcStart` 到 `srcEnd` 指定范围内的字节。 `destStart`、`start` 和 `end` 是可选的，将分别默认为 `dest` 缓冲区的开头以及列表的开头和结尾。

--------------------------------------------------------
<a name="duplicate"></a>
### <a name="blduplicate"></a>bl.duplicate()
`duplicate()` 执行列表的 shallow-copy。 内部缓冲区保持不变，因此，如果更改基础缓冲区，更改将反映在原始缓冲区和重复缓冲区中。 如果要调用 `consume()` 或 `pipe()`，但仍保留原始列表，则需要此方法。例子：

```js
var bl = new BufferListStream()

bl.append('hello')
bl.append(' world')
bl.append('\n')

bl.duplicate().pipe(process.stdout, { end: false })

console.log(bl.toString())
```

--------------------------------------------------------
<a name="consume"></a>
### <a name="blconsumebytes"></a>bl.consume(bytes)
`consume()` 将字节从列表的开头移开。 消耗的字节数不需要与内部缓冲区的大小保持一致 - 将相应计算初始偏移量，以便提供一致的数据视图。

--------------------------------------------------------
<a name="toString"></a>
### <a name="bltostringencoding--start--end-"></a>bl.toString([encoding, [ start, [ end ]]])
`toString()` 将返回缓冲区的字符串表示形式。 可选的 `start` 和 `end` 参数将传递给 `slice()`，而 `encoding` 将传递给生成的缓冲区的 `toString()`。 有关详细信息，请参阅 [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end) 文档。

--------------------------------------------------------
<a name="readXX"></a>
### <a name="blreaddoublebe-blreaddoublele-blreadfloatbe-blreadfloatle-blreadint32be-blreadint32le-blreaduint32be-blreaduint32le-blreadint16be-blreadint16le-blreaduint16be-blreaduint16le-blreadint8-blreaduint8"></a>bl.readDoubleBE(), bl.readDoubleLE(), bl.readFloatBE(), bl.readFloatLE(), bl.readInt32BE(), bl.readInt32LE(), bl.readUInt32BE(), bl.readUInt32LE(), bl.readInt16BE(), bl.readInt16LE(), bl.readUInt16BE(), bl.readUInt16LE(), bl.readInt8(), bl.readUInt8()

`Buffer` 接口的所有标准字节读取方法都已实现，并将透明地跨内部缓冲区边界运行。

请参阅 <b><code>[Buffer](http://nodejs.org/docs/latest/api/buffer.html)</code></b> 文档以了解这些工作原理。

--------------------------------------------------------
<a name="ctorStream"></a>
### <a name="new-bufferliststream-callback--buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferListStream([ callback | Buffer | Buffer array | BufferList | BufferList array | String ])
BufferListStream 是一个 Node **[双工流](http://nodejs.org/docs/latest/api/stream.html#stream_class_stream_duplex)** ，因此可以像标准 Node 流一样读取和写入它。 还可以通过 `pipe()` 传入和传出 BufferListStream 实例。

构造函数采用可选的回调，如果提供，则在调用 `bl.end()`（即从管道流）时，将使用 error 参数调用回调，后跟对 bl 实例的引用。 这是收集流的全部内容的便捷方法，尤其是当流为块区（如网络流）时。

通常，构造函数不需要任何参数，但可以通过传入单个 `Buffer` 对象或 `Buffer` 对象数组来初始化列表。

`new` 并不是硬性要求，但如果不实例化新对象，它将自动为你完成，因此你可以简单地通过以下内容创建新实例：

```js
const { BufferListStream } = require('bl')
const bl = BufferListStream()

// equivalent to:

const { BufferListStream } = require('bl')
const bl = new BufferListStream()
```

N.B. 出于后向兼容性原因，`BufferListStream` 是 `require('bl')` 时的默认导出：

```js
const { BufferListStream } = require('bl')
// equivalent to:
const BufferListStream = require('bl')
```

--------------------------------------------------------

## <a name="contributors"></a>作者

bl 是由以下黑客带给你的：

 * [Rod Vagg](https://github.com/rvagg)
 * [Matteo Collina](https://github.com/mcollina)
 * [Jarett Cruger](https://github.com/jcrugzz)

<a name="license"></a>
## <a name="license-amp-copyright"></a>许可证和版权

版权 (c) 2013-2019 bl 贡献者（上述内容）。

bl 已获 MIT 许可证的许可。 保留 MIT 许可证中未明确授予的所有权利。 有关更多详细信息，请参阅包含的 LICENSE.md 文件。
