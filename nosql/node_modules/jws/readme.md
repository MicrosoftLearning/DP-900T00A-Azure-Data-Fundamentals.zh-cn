---
ms.openlocfilehash: 4d20fe9ebd12ad861676f14f1c8e66479fd1e481
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050521"
---
# <a name="node-jws-build-statushttptravis-ciorgbrianloveswordsnode-jws"></a>node-jws [![版本状态](https://secure.travis-ci.org/brianloveswords/node-jws.svg)](http://travis-ci.org/brianloveswords/node-jws)

[JSON Web 签名](http://self-issued.info/docs/draft-ietf-jose-json-web-signature.html)的实现。

这是针对 `draft-ietf-jose-json-web-signature-08` 开发的，并实现了除 X.509 证书链签名/验证之外的全部规范（可能会进行补充）。

有同步（`jws.sign`、`jws.verify`）和流式处理（`jws.createSign`、`jws.createVerify`）API。

# <a name="install"></a>安装

```bash
$ npm install jws
```

# <a name="usage"></a>使用情况

## <a name="jwsalgorithms"></a>jws.ALGORITHMS

支持的算法数组。 当前支持以下算法。

alg 参数值 | 数字签名或 MAC 算法
----------------|----------------------------
HS256 | 使用 SHA-256 哈希算法的 HMAC
HS384 | 使用 SHA-384 哈希算法的 HMAC
HS512 | 使用 SHA-512 哈希算法的 HMAC
RS256 | 使用 SHA-256 哈希算法的 RSASSA
RS384 | 使用 SHA-384 哈希算法的 RSASSA
RS512 | 使用 SHA-512 哈希算法的 RSASSA
PS256 | 使用 SHA-256 哈希算法的 RSASSA-PSS
PS384 | 使用 SHA-384 哈希算法的 RSASSA-PSS
PS512 | 使用 SHA-512 哈希算法的 RSASSA-PSS
ES256 | 使用 P-256 曲线和 SHA-256 哈希算法的 ECDSA
ES384 | 使用 P-384 曲线和 SHA-384 哈希算法的 ECDSA
ES512 | 使用 P-521 曲线和 SHA-512 哈希算法的 ECDSA
无 | 未包含数字签名或 MAC 值

## <a name="jwssignoptions"></a>jws.sign(options)

（同步）返回标头和有效负载的 JSON Web 签名。

选项：

* `header`
* `payload`
* `secret` 或 `privateKey`
* `encoding`（可选，默认值为“utf8”）

`header` 必须是具有 `alg` 属性的对象。 `header.alg` 必须是 `jws.ALGORITHMS` 中的一个值。 有关支持的算法表，请参见上面的表格。

如果 `payload` 不是缓冲区或字符串，它将使用 `JSON.stringify` 强制转换为字符串。

示例

```js
const signature = jws.sign({
  header: { alg: 'HS256' },
  payload: 'h. jon benjamin',
  secret: 'has a van',
});
```

## <a name="jwsverifysignature-algorithm-secretorkey"></a>jws.verify(signature, algorithm, secretOrKey)

（同步）返回 `true` 或 `false` 以表示签名是否与机密或密钥匹配。

`signature` 是 JWS 签名。 `header.alg` 必须是 `jws.ALGORITHMS` 中的一个值。
有关支持的算法表，请参见上面的表格。 `secretOrKey` 是一个字符串或缓冲区，其中包含 HMAC 算法的机密或 RSA 和 ECDSA 的 PEM 编码公钥。

请注意，将忽略签名标头中的 `"alg"` 值。


## <a name="jwsdecodesignature"></a>jws.decode(signature)

（同步）返回 JWS 签名的已解码标头、已解码有效负载和签名部分。

返回一个包含三个属性的对象，例如：
```js
{ header: { alg: 'HS256' },
  payload: 'h. jon benjamin',
  signature: 'YOWPewyGHKu4Y_0M_vtlEnNlqmFOclqp4Hy6hVHfFT4'
}
```

## <a name="jwscreatesignoptions"></a>jws.createSign(options)

返回新的 SignStream 对象。

选项：

* `header`（必需）
* `payload`
* `key` || `privateKey` || `secret`
* `encoding`（可选，默认值为“utf8”）

除了 `header` 之外，如果事先知道值，所有选项都需要一个字符串或一个缓冲区，或者为方便起见，需要一个流。
使用加密私钥时，`key`/`privateKey`/`secret` 也可能是一个对象，请参阅[加密文档][encrypted-key-docs]。

示例：

```js

// This...
jws.createSign({
  header: { alg: 'RS256' },
  privateKey: privateKeyStream,
  payload: payloadStream,
}).on('done', function(signature) {
  // ...
});

// is equivalent to this:
const signer = jws.createSign({
  header: { alg: 'RS256' },
});
privateKeyStream.pipe(signer.privateKey);
payloadStream.pipe(signer.payload);
signer.on('done', function(signature) {
  // ...
});
```

## <a name="jwscreateverifyoptions"></a>jws.createVerify(options)

返回新的 VerifyStream 对象。

选项：

* `signature`
* `algorithm`
* `key` || `publicKey` || `secret`
* `encoding`（可选，默认值为“utf8”）

如果事先知道值，所有选项都需要一个字符串或一个缓冲区，或者为方便起见，需要一个流。

示例：

```js

// This...
jws.createVerify({
  publicKey: pubKeyStream,
  signature: sigStream,
}).on('done', function(verified, obj) {
  // ...
});

// is equivilant to this:
const verifier = jws.createVerify();
pubKeyStream.pipe(verifier.publicKey);
sigStream.pipe(verifier.signature);
verifier.on('done', function(verified, obj) {
  // ...
});
```

## <a name="class-signstream"></a>类：SignStream

完成后发出单个数据事件（计算的签名）的 `Readable Stream`。

### <a name="event-done"></a>事件：“完成”
`function (signature) { }`

### <a name="signerpayload"></a>signer.payload

需要 JWS 有效负载的 `Writable Stream`。 如果向构造函数传递了 `payload` 选项，请勿使用。

示例：

```js
payloadStream.pipe(signer.payload);
```

### <a name="signersecretbrsignerkeybrsignerprivatekey"></a>signer.secret<br>signer.key<br>signer.privateKey

一个 `Writable Stream`。 需要 JWS 机密（对于 HMAC）或 privateKey（对于 ECDSA 和 RSA）。 如果向构造函数传递了 `secret` 或 `key` 选项，请勿使用。

例如：

```js
privateKeyStream.pipe(signer.privateKey);
```

## <a name="class-verifystream"></a>类：VerifyStream

这是发出单个数据事件（即确定签名是否有效的结果）的 `Readable Stream`。

### <a name="event-done"></a>事件：“完成”
`function (valid, obj) { }`

`valid` 是表示签名是否有效的布尔值。

### <a name="verifiersignature"></a>verifier.signature

需要 JWS 签名的 `Writable Stream`。 如果向构造函数传递了 `signature` 选项，请勿使用。

### <a name="verifiersecretbrverifierkeybrverifierpublickey"></a>verifier.secret<br>verifier.key<br>verifier.publicKey

需要公钥或机密的 `Writable Stream`。 如果向构造函数传递了 `key` 或 `secret` 选项，请勿使用。

# <a name="todo"></a>TODO

* 应该有一些方便的选项/API 可用来定义算法，而不是每次都必须使用 `{ alg: 'ES512' }` 或其他值来定义标头对象。

* 没错，是 X.509 支持

# <a name="license"></a>许可

MIT

```
Copyright (c) 2013-2015 Brian J. Brennan

Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

[encrypted-key-docs]: https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format
