---
ms.openlocfilehash: c0d4bfc80d62125554d466fe2b45375ed815b043
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050698"
---
# <a name="jsonwebtoken"></a>jsonwebtoken

| **生成** | **依赖项** |
|-----------|---------------|
| [![生成状态](https://secure.travis-ci.org/auth0/node-jsonwebtoken.svg?branch=master)](http://travis-ci.org/auth0/node-jsonwebtoken) | [![依赖项状态](https://david-dm.org/auth0/node-jsonwebtoken.svg)](https://david-dm.org/auth0/node-jsonwebtoken) |


[JSON Web 令牌](https://tools.ietf.org/html/rfc7519)的实现。

这是针对 `draft-ietf-oauth-json-web-token-08` 开发的。 它利用 [node-jws](https://github.com/brianloveswords/node-jws)

# <a name="install"></a>安装

```bash
$ npm install jsonwebtoken
```

# <a name="migration-notes"></a>迁移说明

* [从 v7 到 v8](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v7-to-v8)

# <a name="usage"></a>使用情况

### <a name="jwtsignpayload-secretorprivatekey-options-callback"></a>jwt.sign(payload, secretOrPrivateKey, [options, callback])

（异步）如果提供了回调，则使用 `err` 或 JWT 调用回调。

（同步）以字符串形式返回 JsonWebToken

`payload` 可以是表示有效 JSON 的对象文字、缓冲区或字符串。 
> 请注意，`exp` 或任何其他声明仅在有效负载是对象文字时才设置。 不会检查缓冲区或字符串有效负载的 JSON 有效性。

> 如果 `payload` 不是缓冲区或字符串，则会使用 `JSON.stringify` 将其强制转换为字符串。

`secretOrPrivateKey` 是包含 HMAC 算法的机密或 RSA 和 ECDSA 的 PEM 编码私钥的字符串、缓冲区或对象。 对于具有密码的私钥，可以使用 `{ key, passphrase }` 对象（根据[加密文档](https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format)），在这种情况下，请确保传递 `algorithm` 选项。

`options`:

* `algorithm`（默认为 `HS256`）
* `expiresIn`：以秒或描述时间跨度 [zeit/ms](https://github.com/zeit/ms) 的字符串表示。 
  > 例如：`60`、`"2 days"`、`"10h"`、`"7d"`。 数值以秒数形式解释。 如果使用字符串，请确保提供时间单位（天、小时等），否则默认使用毫秒单位（`"120"` 等于 `"120ms"`）。
* `notBefore`：以秒或描述时间跨度 [zeit/ms](https://github.com/zeit/ms) 的字符串表示。 
  > 例如：`60`、`"2 days"`、`"10h"`、`"7d"`。 数值以秒数形式解释。 如果使用字符串，请确保提供时间单位（天、小时等），否则默认使用毫秒单位（`"120"` 等于 `"120ms"`）。
* `audience`
* `issuer`
* `jwtid`
* `subject`
* `noTimestamp`
* `header`
* `keyid`
* `mutatePayload`：如果为 true，sign 函数将直接修改有效负载对象。 如果需要在将声明应用到有效负载之后、但在将有效负载编码为令牌之前对有效负载进行原始引用，则这非常有用。



> `expiresIn`、`notBefore`、`audience`、`subject` 和 `issuer` 没有默认值。  这些声明也可以分别通过 `exp`、`nbf`、`aud`、`sub` 和 `iss` 直接在有效负载中提供，但不能同时包含在两个位置。

请记住，`exp`、`nbf` 和 `iat` 是 NumericDate，请参阅相关的[令牌过期（exp 声明）](#token-expiration-exp-claim)


可通过 `options.header` 对象自定义标头。

除非指定 `noTimestamp`，否则生成的 jwt 将默认包含 `iat` 声明（颁发时间）。 如果在有效负载中插入 `iat`，则将使用它而不是实际时间戳来计算其他内容，例如 `options.expiresIn` 中给定时间跨度的 `exp`。

具有默认值 (HMAC SHA256) 的同步签名

```js
var jwt = require('jsonwebtoken');
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');
```

具有 RSA SHA256 的同步签名
```js
// sign with RSA SHA256
var privateKey = fs.readFileSync('private.key');
var token = jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256'});
```

异步签名
```js
jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' }, function(err, token) {
  console.log(token);
});
```

回溯 jwt 30 秒
```js
var older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh');
```

#### <a name="token-expiration-exp-claim"></a>令牌过期（exp 声明）

JWT 的标准定义过期时间的 `exp` 声明。 过期时间以 NumericDate 形式表示：

> 一个 JSON 数值，表示从 1970-01-01T00:00:00Z UTC 到指定 UTC 日期/时间的秒数，忽略闰秒。  这相当于 IEEE Std 1003.1 2013 版 [POSIX.1] 定义“自时期以来的秒数”，在该定义中，每天都精确地用 86400 秒来表示，而不是用非整数值表示。  请参阅 RFC 3339 [RFC3339]，了解有关日期/时间的常规信息和 UTC 的特别信息。

这意味着 `exp` 字段应包含自时期以来的秒数。

使用 1 小时的有效期限对令牌进行签名：

```javascript
jwt.sign({
  exp: Math.floor(Date.now() / 1000) + (60 * 60),
  data: 'foobar'
}, 'secret');
```

使用此库生成类似令牌的另一种方法是：

```javascript
jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: 60 * 60 });

//or even better:

jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: '1h' });
```

### <a name="jwtverifytoken-secretorpublickey-options-callback"></a>jwt.verify(token, secretOrPublicKey, [options, callback])

（异步）如果提供了回调，函数将异步运行。 如果签名有效且可选过期时间、受众或颁发者均有效，则使用已解码的有效负载调用回调。 否则调用时将出现错误。

（同步）如果提供了回调，函数将同步运行。 如果签名有效且可选过期时间、受众或颁发者均有效，则返回已解码的有效负载。 否则将引发错误。

`token` 是 JsonWebToken 字符串

`secretOrPublicKey` 是包含 HMAC 算法的机密或 RSA 和 ECDSA 的 PEM 编码公钥的字符串或缓冲区。
如果异步调用 `jwt.verify`，则 `secretOrPublicKey` 可以是应提取机密或公钥的函数。 有关详细示例，请参阅下文

如[此注释](https://github.com/auth0/node-jsonwebtoken/issues/208#issuecomment-231861138)中所述，还有其他库需要 base64 编码的机密（使用 base64 编码的随机字节），如果你遇到这种情况，可传递 `Buffer.from(secret, 'base64')`，这样操作后，机密将使用 base64 解码，令牌验证将使用原始随机字节。

`options`

* `algorithms`：包含允许的算法名称的字符串列表。 例如：`["HS256", "HS384"]`。
* `audience`：如果要检查受众 (`aud`)，请在此处提供一个值。 可根据字符串、正则表达式或字符串和/或正则表达式列表检查受众。 
  > 例如：`"urn:foo"`、`/urn:f[o]{2}/`、`[/urn:f[o]{2}/, "urn:bar"]`
* `complete`：返回具有已解码 `{ payload, header, signature }` 的对象，而不是仅返回有效负载的常规内容。
* `issuer`（可选）：`iss` 字段的有效值的字符串或字符串数组。
* `ignoreExpiration`：如果为 `true`，则不验证令牌的过期时间。
* `ignoreNotBefore`...
* `subject`：如果要检查使用者 (`sub`)，请在此处提供一个值
* `clockTolerance`：检查 `nbf` 和 `exp` 声明时允许的秒数，用于处理不同服务器之间的微小时钟差异
* `maxAge`：允许的令牌仍然有效的最长期限。 以秒或描述时间跨度 [zeit/ms](https://github.com/zeit/ms) 的字符串表示。 
  > 例如：`1000`、`"2 days"`、`"10h"`、`"7d"`。 数值以秒数形式解释。 如果使用字符串，请确保提供时间单位（天、小时等），否则默认使用毫秒单位（`"120"` 等于 `"120ms"`）。
* `clockTimestamp`：应用作所有必要比较的当前时间的时间（以秒为单位）。
* `nonce`：如果要检查 `nonce` 声明，请在此处提供字符串值。 它用于 ID 令牌的 Open ID。 （[Open ID 实现说明](https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes)）


```js
// verify a token symmetric - synchronous
var decoded = jwt.verify(token, 'shhhhh');
console.log(decoded.foo) // bar

// verify a token symmetric
jwt.verify(token, 'shhhhh', function(err, decoded) {
  console.log(decoded.foo) // bar
});

// invalid token - synchronous
try {
  var decoded = jwt.verify(token, 'wrong-secret');
} catch(err) {
  // err
}

// invalid token
jwt.verify(token, 'wrong-secret', function(err, decoded) {
  // err
  // decoded undefined
});

// verify a token asymmetric
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, function(err, decoded) {
  console.log(decoded.foo) // bar
});

// verify audience
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo' }, function(err, decoded) {
  // if audience mismatch, err == invalid audience
});

// verify issuer
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer' }, function(err, decoded) {
  // if issuer mismatch, err == invalid issuer
});

// verify jwt id
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid' }, function(err, decoded) {
  // if jwt id mismatch, err == invalid jwt id
});

// verify subject
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' }, function(err, decoded) {
  // if subject mismatch, err == invalid subject
});

// alg mismatch
var cert = fs.readFileSync('public.pem'); // get public key
jwt.verify(token, cert, { algorithms: ['RS256'] }, function (err, payload) {
  // if token alg != RS256,  err == invalid signature
});

// Verify using getKey callback
// Example uses https://github.com/auth0/node-jwks-rsa as a way to fetch the keys.
var jwksClient = require('jwks-rsa');
var client = jwksClient({
  jwksUri: 'https://sandrino.auth0.com/.well-known/jwks.json'
});
function getKey(header, callback){
  client.getSigningKey(header.kid, function(err, key) {
    var signingKey = key.publicKey || key.rsaPublicKey;
    callback(null, signingKey);
  });
}

jwt.verify(token, getKey, options, function(err, decoded) {
  console.log(decoded.foo) // bar
});

```

### <a name="jwtdecodetoken--options"></a>jwt.decode(token [, options])

（同步）返回已解码的有效负载，而不验证签名是否有效。

> __警告：__ 这不会验证签名是否有效。 不应将此用于不受信任的消息。 建议改用 `jwt.verify`。

`token` 是 JsonWebToken 字符串

`options`:

* `json`：强制对有效负载执行 JSON.parse，即使标头不包含 `"typ":"JWT"`。
* `complete`：返回具有已解码的有效负载和标头的对象。

示例

```js
// get the decoded payload ignoring signature, no secretOrPrivateKey needed
var decoded = jwt.decode(token);

// get the decoded payload and header
var decoded = jwt.decode(token, {complete: true});
console.log(decoded.header);
console.log(decoded.payload)
```

## <a name="errors--codes"></a>错误和代码
验证期间可能引发的错误。
错误是验证回调的第一个参数。

### <a name="tokenexpirederror"></a>TokenExpiredError

如果令牌已过期，则引发错误。

错误对象：

* 名称：“TokenExpiredError”
* 消息：“jwt 已过期”
* expiredAt: [ExpDate]

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'TokenExpiredError',
        message: 'jwt expired',
        expiredAt: 1408621000
      }
    */
  }
});
```

### <a name="jsonwebtokenerror"></a>JsonWebTokenError
错误对象：

* 名称：“JsonWebTokenError”
* 消息:
  * “jwt 格式错误”
  * “需要 jwt 签名”
  * “签名无效”
  * “jwt 受众无效。 应为：[OPTIONS AUDIENCE]”
  * “jwt 颁发者无效。 应为：[OPTIONS ISSUER]”
  * “jwt id 无效。 应为：[OPTIONS JWT ID]”
  * “jwt 使用者无效。 应为：[OPTIONS SUBJECT]”

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'JsonWebTokenError',
        message: 'jwt malformed'
      }
    */
  }
});
```

### <a name="notbeforeerror"></a>NotBeforeError
如果当前时间早于 nbf 声明，则引发此错误。

错误对象：

* 名称：“NotBeforeError”
* 消息：“jwt 未处于活动状态”
* date：2018-10-04T16:10:44.000Z

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'NotBeforeError',
        message: 'jwt not active',
        date: 2018-10-04T16:10:44.000Z
      }
    */
  }
});
```


## <a name="algorithms-supported"></a>支持的算法

支持的算法数组。 当前支持以下算法。

alg 参数值 | 数字签名或 MAC 算法
----------------|----------------------------
HS256 | 使用 SHA-256 哈希算法的 HMAC
HS384 | 使用 SHA-384 哈希算法的 HMAC
HS512 | 使用 SHA-512 哈希算法的 HMAC
RS256 | 使用 SHA-256 哈希算法的 RSASSA-PKCS1-v1_5
RS384 | 使用 SHA-384 哈希算法的 RSASSA-PKCS1-v1_5
RS512 | 使用 SHA-512 哈希算法的 RSASSA-PKCS1-v1_5
PS256 | 使用 SHA-256 哈希算法的 RSASSA-PSS（仅限 node ^6.12.0 或 8.0.0 及更高版本）
PS384 | 使用 SHA-384 哈希算法的 RSASSA-PSS（仅限 node ^6.12.0 或 8.0.0 及更高版本）
PS512 | 使用 SHA-512 哈希算法的 RSASSA-PSS（仅限 node ^6.12.0 或 8.0.0 及更高版本）
ES256 | 使用 P-256 曲线和 SHA-256 哈希算法的 ECDSA
ES384 | 使用 P-384 曲线和 SHA-384 哈希算法的 ECDSA
ES512 | 使用 P-521 曲线和 SHA-512 哈希算法的 ECDSA
无 | 未包含数字签名或 MAC 值

## <a name="refreshing-jwts"></a>刷新 JWT

首先，我们建议仔细考虑自动刷新 JWT 是否会在系统中引入任何漏洞。

我们不太愿意将此内容作为库的一部分，但你可以查看[此示例](https://gist.github.com/ziluvatar/a3feb505c4c0ec37059054537b38fc48)来了解它是如何完成的。
除了该示例外，还有[一个问题](https://github.com/auth0/node-jsonwebtoken/issues/122)和[一个拉取请求](https://github.com/auth0/node-jsonwebtoken/pull/172)，可用于获取有关本主题的更多知识。

# <a name="todo"></a>TODO

* 未检查 X.509 证书链

## <a name="issue-reporting"></a>问题报告

如果发现 bug 或有功能请求，请在此存储库的问题部分报告它们。 请勿在公共 GitHub 问题跟踪器上报告安全漏洞。 [责任披露计划](https://auth0.com/whitehat)详细说明了披露安全问题的过程。

## <a name="author"></a>作者

[Auth0](https://auth0.com)

## <a name="license"></a>许可

此项目已获 MIT 许可证的许可。 有关详细信息，请参阅[许可证](LICENSE)文件。
