---
ms.openlocfilehash: ca2cf748b426d17058b55202a60ece01d9e05592
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050689"
---
# <a name="node-abort-controller"></a>node-abort-controller

基于 EventEmitter 的 AbortController Polyfill for Node.JS

[![生成状态](https://dev.azure.com/stfaul/node-abort-controller/_apis/build/status/southpolesteve.node-abort-controller?branchName=master)](https://dev.azure.com/stfaul/node-abort-controller/_build/latest?definitionId=3&branchName=master)

## <a name="usage"></a>使用情况

```js
import fetch from 'node-fetch'
import AbortController from 'node-abort-controller'

const controller = new AbortController()
const signal = controller.signal

await fetch('https:/www.google.com', { signal })

// Abort after 500ms. Effectively a timeout
setTimeout(() => controller.abort(), 500)
```

## <a name="why-would-i-use-this"></a>为何我要使用此项？

你可能不需要！ 一般来说，JavaScript 代码可以在以下三个环境中运行：

- 节点
- 新式浏览器（不是 Internet Explorer）
- 旧版浏览器（主要是 Internet Explorer）

对于新式 JS API，每个环境理想情况下都会获得一个 polyfill：

- 仅当它需要一个
- 特定于平台。

在实践中，这是很难的。 像 webpack 和 browserify 这样的工具非常适合确保内容在所有环境中开箱即用。 但是，在上述两点上都很容易失败。 很有可能，你最终会在甚至不需要它们的平台上发布不太理想的 polyfill。 那么开发人员该怎么办？ 就 `fetch` 和 `AbortController` 而言，我已经为你完成了这项工作。 这是该工作的指南。

如果要构建 ...

#### <a name="application-running-in-modern-browsers"></a>在新式浏览器中运行的应用程序：

恭喜！ 根本不需要库或 polyfill！ 关闭此选项卡。卸载此包。

#### <a name="application-running-in-modern-browsers-and-node-such-as-a-server-side-rendered-js-app"></a>在新式浏览器和节点中运行的应用程序（例如服务器端呈现的 JS 应用）：

使用此包和 [node-fetch](https://www.npmjs.com/package/node-fetch)。 这是必不可少的。

#### <a name="application-supporting-legacy-browsers-and-not-node"></a>支持旧版浏览器但不支持节点的应用程序：

使用 [abort-controller](https://www.npmjs.com/package/abort-controller) 和 [whatwg-fetch](https://www.npmjs.com/package/whatwg-fetch)。 这些是更完整的 polyfill，可以在所有浏览器环境中使用。

#### <a name="application-supporting-legacy-browsers-and-node"></a>支持旧版浏览器和节点的应用程序：

使用 [abort-controller](https://www.npmjs.com/package/abort-controller) 和 [cross-fetch](https://www.npmjs.com/package/cross-fetch)。 与上述相同，除了 cross-fetch 将在浏览器和 node.js 中正确进行 polyfill

#### <a name="library-being-consumed-by-other-applications-and-using-fetch-internally"></a>库由其他应用程序使用并在内部使用 `fetch`：

使用此包和 [node-fetch](https://www.npmjs.com/package/node-fetch)。 对于最终用户来说，这是最小和最不固执的组合。 面向 Internet Exploer 的应用程序开发人员将需要自行对 `AbortController` 和 `fetch` 进行 polyfill。 但是，你的库不会将不必要的 polyfill 强加给仅面向新式浏览器的开发人员。

## <a name="goals"></a>目标

考虑到上述指南，此库具有一组非常具体的目标：

1. 在 node.js 中提供最少的 polyfill
2. 请勿在任何浏览器环境中提供 polyfill

这是库作者的理想选择，他们在内部使用 `fetch` 和 `AbortController`，并面向浏览器和节点开发人员 。

## <a name="prior-art"></a>先前技术

谢谢 @mysticatea 的 https://github.com/mysticatea/abort-controller 。 这是一个很不错的 `AbortController` polyfill，对许多用例都适用。
