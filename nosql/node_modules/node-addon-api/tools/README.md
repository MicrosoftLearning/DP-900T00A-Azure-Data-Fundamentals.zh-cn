---
ms.openlocfilehash: 3decbdeed6f0c742925a5be9b78f5251a4c0b569
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050562"
---
# <a name="tools"></a>工具

## <a name="clang-format"></a>clang-format

clang-format 检查工具旨在检查与给定 git-refs 相比更改的代码行。

## <a name="migration-script"></a>迁移脚本

迁移工具旨在减少迁移过程中的重复性工作。 但该脚本的目的并非是转换所有内容。 通常需要进行一些细小修复和重要重建。

### <a name="how-to-use"></a>使用方式

若要运行转换脚本，请先确保 `node_modules` 目录中有最新的 `node-addon-api`。
```
npm install node-addon-api
```

然后运行传递项目目录的脚本
```
node ./node_modules/node-addon-api/tools/conversion.js ./
```

完成后，重新编译和调试脚本遗漏的内容。


### <a name="quick-fixes"></a>快速修复
下面是可以轻松修复的内容列表。
  1. 如果方法未将值返回到 JavaScript，请将方法的返回值更改为 void。
  2. 在 Napi::Object 中使用 `.`（而不是 `->`）来访问属性或调用成员函数。
  3. `Napi::New(env, value);` 到 `Napi::[Type]::New(env, value);


### <a name="major-reconstructions"></a>重要重建
`Napi::ObjectWrap` 的实现与 NAN 的实现有很大不同。 `Napi::ObjectWrap` 采用一个指向包装对象的指针，并在 ObjectWrap 构造函数中创建对包装对象的引用。 `Napi::ObjectWrap` 还将包装对象的实例方法关联到 Javascript 模块，而不是静态方法（例如 NAN）。

因此，如果在模块中使用 Nan::ObjectWrap，需执行以下步骤。

  1. 将 [ClassName]::New 函数转换为采用 `Napi::CallbackInfo` 的构造函数。 将其声明为
```
[ClassName](const Napi::CallbackInfo& info);
```
并将其定义为
```
[ClassName]::[ClassName](const Napi::CallbackInfo& info) : Napi::ObjectWrap<[ClassName]>(info){
  ...
}
```
这样，在对象实例化后将调用 `Napi::ObjectWrap` 构造函数，并且 `Napi::ObjectWrap` 可以使用 `this` 指针创建对包装对象的引用。

  2. 将原始构造函数代码移动到新构造函数中。 删除原始构造函数。
  3. 在类初始化函数中，按以下方式关联原生方法。
```
Napi::FunctionReference constructor;

void [ClassName]::Init(Napi::Env env, Napi::Object exports, Napi::Object module) {
  Napi::HandleScope scope(env);
  Napi::Function ctor = DefineClass(env, "Canvas", {
    InstanceMethod<&[ClassName]::Func1>("Func1"),
    InstanceMethod<&[ClassName]::Func2>("Func2"),
    InstanceAccessor<&[ClassName]::ValueGetter>("Value"),
    StaticMethod<&[ClassName]::StaticMethod>("MethodName"),
    InstanceValue("Value", Napi::[Type]::New(env, value)),
  });

  constructor = Napi::Persistent(ctor);
  constructor .SuppressDestruct();
  exports.Set("[ClassName]", ctor);
}
```
  4. 在需要在 NAN 中展开 ObjectWrap 的函数中（如 `[ClassName]* native = Nan::ObjectWrap::Unwrap<[ClassName]>(info.This());`），可直接使用 `this` 指针作为展开对象，因为每个 ObjectWrap 实例都与一个唯一的对象实例相关联。


如果按照本指南操作后仍发现问题，请给我们留言，描述你的问题，我们将努力解决。
