---
ms.openlocfilehash: 4f36d4681facd228c63b48050973040e9785d30f
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050573"
---

<a name="microsoft-authentication-library-for-javascript-msaljs"></a>适用于 JavaScript 的 Microsoft 身份验证库 (MSAL.js)
=========================================================

| [入门](https://docs.microsoft.com/azure/active-directory/develop/guidedsetups/active-directory-javascriptspa)| [AAD Docs](https://aka.ms/aaddevv2) | [库参考](https://azuread.github.io/microsoft-authentication-library-for-js/ref/modules/_azure_msal.html) | [支持](README.md#community-help-and-support) | [示例](https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/Samples)
| --- | --- | --- | --- | --- |

⚠️⚠️⚠️ 此库不再接收新功能，只会收到关键 bug 和安全修补程序。 所有新应用程序都应该改用 [@azure/msal-browser](https://www.npmjs.com/package/@azure/msal-browser)。 ⚠️⚠️⚠️

适用于 JavaScript 的 MSAL 支持在 Web 浏览器中运行的客户端 JavaScript 应用程序通过 [Azure AD B2C](https://docs.microsoft.com/azure/active-directory-b2c/active-directory-b2c-overview#identity-providers) 服务使用 [Azure AD](https://docs.microsoft.com/azure/active-directory/develop/v2-overview) 工作和学校帐户 (AAD)、Microsoft 个人帐户 (MSA)、社交标识提供者（Facebook、Google、LinkedIn 等）、Microsoft 帐户等对用户进行身份验证。 它还使应用能够获取令牌以访问 [Microsoft Cloud](https://www.microsoft.com/enterprise) 服务，例如 [Microsoft Graph](https://graph.microsoft.io)。

[![npm 版本](https://img.shields.io/npm/v/msal.svg?style=flat)](https://www.npmjs.com/package/msal)
[![npm 版本](https://img.shields.io/npm/dm/msal.svg)](https://nodei.co/npm/msal/)
[![codecov](https://codecov.io/gh/AzureAD/microsoft-authentication-library-for-js/branch/dev/graph/badge.svg?flag=msal-core)](https://codecov.io/gh/AzureAD/microsoft-authentication-library-for-js)

## <a name="installation"></a>安装

### <a name="via-npm"></a>通过 NPM：

    npm install msal

## <a name="via-cdn"></a>通过 CDN：

<!-- CDN_LATEST -->
```html
<script type="text/javascript" src="https://alcdn.msauth.net/lib/1.4.11/js/msal.min.js"></script>
```

我们的文档中提供了有关 CDN 用法的[完整详细信息和最佳做法](https://github.com/AzureAD/microsoft-authentication-library-for-js/blob/dev/lib/msal-core/docs/cdn.md)。

## <a name="what-to-expect-from-this-library"></a>此库中包含的内容
Javascript 上的 MSAL 支持是库的集合。 `msal-core`（简称为 `msal`）是不限制框架的核心库。 在核心 1.x+ 稳定后，我们将使用最新的 1.x 改进来引入 `msal-angular` 库。  我们计划根据框架和库的使用趋势弃用对 `msal-angularjs` 的支持，这表明越来越多地采用 Angular 2+，而不是 Angular 1x。 在当前库达到标准后，我们将开始平衡新功能请求，以及新的平台（如 `react` 和 `node.js`）。

我们的目标是与社区进行非常良好的交流并考虑到他们的意见。 我们希望获得月次要版本发布计划，并根据需要提供修补程序。  我们想要实现的沟通、计划和粒度水平是我们当前正在进行的工作。

请查看我们的[路线图](https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki#roadmap)以查看我们当前以及接下来的工作内容。

## <a name="oauth-20-and-the-implicit-flow"></a>OAuth 2.0 和隐式流

Msal 实现[隐式授权流](https://docs.microsoft.com/azure/active-directory/develop/v2-oauth2-implicit-grant-flow)，由 OAuth 2.0 协议定义，并且符合 [OpenID](https://docs.microsoft.com/azure/active-directory/develop/v2-protocols-oidc)。

我们的目标是，库抽象出足够多的协议，以便你可以获取即插即用身份验证，但是从安全角度来了解和理解隐式流程非常重要。
隐式流在无法安全地管理客户端机密的 Web 浏览器的上下文中运行。 它针对单页应用进行了优化，客户端和服务器之间的跃点较少，因此令牌会直接返回到浏览器。 这些方面使它自然不那么安全。
缓解这些安全问题的标准做法有：使用短期令牌（因此不返回刷新令牌）、库要求应用使用已注册的重定向 URI、库使用唯一的 nonce 和 state 参数匹配请求和响应。

## <a name="cache-storage"></a>缓存存储

我们为 MSAL 提供两种存储方法：`localStorage` 以及 `sessionStorage`.  建议使用 `sessionStorage`，因为它可以更安全地存储用户获取的令牌，但使用 `localStorage` 可以在不同的选项卡和用户会话中实现单一登录。  我们将介绍这些选项，并针对你的应用程序做出最佳决策。

### <a name="forcerefresh-to-skip-cache"></a>用于跳过缓存的 forceRefresh
如果要跳过缓存的令牌并转到服务器，请将布尔值 `forceRefresh` 传入到用于发出登录/令牌请求的 `AuthenticationParameters` 对象。 警告：默认情况下不应使用，因为对应用程序存在性能影响。  依赖缓存会为用户提供更好的体验，并且只应在知道当前缓存的数据没有最新信息的情况下使用它。  示例：用于向需要获取具有更新角色的新令牌的用户添加角色的管理工具。

## <a name="usage"></a>使用情况
以下示例将引导你完成如何登录用户并获取用于 Microsoft Graph API 的令牌。

#### <a name="prerequisites"></a>先决条件

在使用 MSAL.js 之前，需要[在 Azure AD 中注册应用程序](https://docs.microsoft.com/azure/active-directory/develop/quickstart-register-app)，以获取有效的 `clientId` 配置，并注册应用将接受重定向流量的路由。

#### <a name="1-instantiate-the-useragentapplication"></a>1.实例化 UserAgentApplication

`UserAgentApplication` 可以使用各种不同的选项进行配置（详见我们的 [Wiki](https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/MSAL.js-1.0.0-api-release#configuration-options)），但唯一必需的参数是 `auth.clientId`。

实例化实例后，如果你打算在 MSAL 1.2.x 或更早版本中使用重定向流（`loginRedirect` 和 `acquireTokenRedirect`），则必须使用 `handleRedirectCallback(authCallback)`（其中 `authCallback = function(AuthError, AuthResponse)`）注册回调处理程序。 从 MSAL 1.3.0 起，这是可选的。 身份验证请求成功完成或失败后，将调用回调函数。 弹出窗口流不需要这样做，因为它们返回承诺。

```JavaScript
    import * as Msal from "msal";
    // if using cdn version, 'Msal' will be available in the global scope

    const msalConfig = {
        auth: {
            clientId: 'your_client_id'
        }
    };

    const msalInstance = new Msal.UserAgentApplication(msalConfig);

    msalInstance.handleRedirectCallback((error, response) => {
        // handle redirect response or error
    });

```

有关配置选项的详细信息，请阅读[使用 MSAL.js 初始化客户端应用程序](https://docs.microsoft.com/azure/active-directory/develop/msal-js-initializing-client-applications)。

#### <a name="2-login-the-user"></a>2.登录用户

你的应用程序必须使用 `loginPopup` 或 `loginRedirect` 方法登录用户以建立用户上下文。

当调用登录方法并通过 Azure AD 服务完成用户的身份验证时，返回 [ID 令牌](https://docs.microsoft.com/azure/active-directory/develop/id-tokens)，用于使用一些基本信息来标识用户。

登录用户时，可以传入用户预先同意登录的范围，但这不是必需的。 请注意，同意登录范围不会返回这些范围的 access_token，但让你有机会在传入这些范围的情况下以无提示方式获取令牌，而无需进一步与用户交互。

最佳做法是仅在需要时请求需要的范围，这一概念称为动态同意。 虽然这可以为应用程序中的用户创建更多的交互式同意，但它也减少了用户的流失，这些用户可能会为针对他们尚未使用的功能授予大量权限而感到不安。

AAD 一次只允许获得 3 个资源的同意，尽管你可以在资源中请求许多范围。
当用户发出登录请求时，你可以传入多个资源及其对应的范围，因为 AAD 会发出一个 idToken，以预先同意这些范围。 但是，acquireToken 调用仅对一个资源/多个范围有效。 如果需要访问多个资源，请针对每个资源单独调用 acquireToken。

```JavaScript
   var loginRequest = {
       scopes: ["user.read", "mail.send"] // optional Array<string>
   };

    msalInstance.loginPopup(loginRequest)
        .then(response => {
            // handle response
        })
        .catch(err => {
            // handle error
        });

```

##### <a name="ssosilent"></a>ssoSilent

如果确信用户具有现有会话，并且想要在不提示交互的情况下建立用户上下文，则可以使用 `loginHint` 或 `sid` 调用 `ssoSilent`（作为[可选声明](https://docs.microsoft.com/azure/active-directory/develop/active-directory-optional-claims)），MSAL 将尝试以无提示方式 SSO 登录到现有会话并建立用户上下文。

请注意，如果给定 `loginHint` 或 `sid` 没有主动会话，则将引发错误，应通过调用交互式登录方法（`loginPopup` 或 `loginRedirect`）来处理。

示例：

```js
const ssoRequest = {
    loginHint: "user@example.com"
};

msalInstance.ssoSilent(ssoRequest)
    .then(response => {
        // session silently established
    })
    .catch(error => {
        // handle error by invoking an interactive login method
        msalInstance.loginPopup(ssoRequest);
    });
```

#### <a name="3-get-an-access-token-to-call-an-api"></a>3.获取访问令牌以调用 API

在 MSAL 中，可以使用 `acquireTokenSilent` 方法来获得应用需要调用的 API 的访问令牌，该方法对 Azure AD 提出无提示请求（不使用 UI 提示用户）以获取访问令牌。 然后，Azure AD 服务返回包含用户同意范围的[访问令牌](https://docs.microsoft.com/azure/active-directory/develop/access-tokens)，以允许你的应用安全调用 API。

虽然可以使用 `acquireTokenRedirect` 或 `acquireTokenPopup` 启动交互式请求，但最佳做法是仅当由于交互所需的错误而无法以无提示方式获取令牌时显示交互式体验。 如果使用交互式令牌调用，它必须与应用程序中使用的登录方法匹配。 (`loginPopup`=> `acquireTokenPopup`, `loginRedirect` => `acquireTokenRedirect`).

如果 `acquireTokenSilent` 调用失败并出现 `InteractionRequiredAuthError` 类型的错误，则需要启动交互式请求。  发生此错误的原因有很多，包括范围已撤销、过期令牌或密码更改。

`acquireTokenSilent` 将在缓存中查找有效的令牌，如果它即将过期或不存在，将自动尝试为你刷新。

有关参考，请参阅[请求和响应数据类型](https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/MSAL.js-1.0.0-api-release#signing-in-and-getting-tokens-with-msaljs)。

```JavaScript
    // if the user is already logged in you can acquire a token
    if (msalInstance.getAccount()) {
        var tokenRequest = {
            scopes: ["user.read", "mail.send"]
        };
        msalInstance.acquireTokenSilent(tokenRequest)
            .then(response => {
                // get access token from response
                // response.accessToken
            })
            .catch(err => {
                // could also check if err instance of InteractionRequiredAuthError if you can import the class.
                if (err.name === "InteractionRequiredAuthError") {
                    return msalInstance.acquireTokenPopup(tokenRequest)
                        .then(response => {
                            // get access token from response
                            // response.accessToken
                        })
                        .catch(err => {
                            // handle error
                        });
                }
            });
    } else {
        // user is not logged in, you will need to log them in to acquire a token
    }
```

#### <a name="4-use-the-token-as-a-bearer-in-an-http-request-to-call-the-microsoft-graph-or-a-web-api"></a>4.使用令牌作为 HTTP 请求中的持有者来调用 Microsoft Graph 或 Web API

```JavaScript
    var headers = new Headers();
    var bearer = "Bearer " + token;
    headers.append("Authorization", bearer);
    var options = {
         method: "GET",
         headers: headers
    };
    var graphEndpoint = "https://graph.microsoft.com/v1.0/me";

    fetch(graphEndpoint, options)
        .then(resp => {
             //do something with response
        });
```

你可以在 [MSAL Wiki](https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki) 中了解有关 MSAL.js 功能的更多详细信息，并查找完整的[代码示例](https://github.com/AzureAD/microsoft-authentication-library-for-js/wiki/Samples)。

## <a name="security-reporting"></a>安全报告

如果发现我们的库或服务存在安全问题，请向 [secure@microsoft.com](mailto:secure@microsoft.com) 报告，并提供尽可能多的详细信息。 你的提交可能有资格通过 [Microsoft 赏金](http://aka.ms/bugbounty)计划获得赏金。 请不要将安全问题发布到 GitHub 问题或任何其他公共站点。 我们在收到信息后会尽快与你取得联系。 建议发生安全事件时获取相关通知，方法是访问 [此页](https://technet.microsoft.com/security/dd252948) 并订阅“安全公告通知”。

## <a name="license"></a>许可

版权所有 (c) Microsoft Corporation。  保留所有权利。 已获得 MIT 许可证（以下简称“许可证”）的许可；

## <a name="we-value-and-adhere-to-the-microsoft-open-source-code-of-conduct"></a>我们重视并遵守 Microsoft 开源行为准则

此项目采用了 [Microsoft 开放源代码行为准则](https://opensource.microsoft.com/codeofconduct/)。 有关详细信息，请参阅[行为准则常见问题](https://opensource.microsoft.com/codeofconduct/faq/)，或如果有任何其他问题或意见，请与 [opencode@microsoft.com](mailto:opencode@microsoft.com) 联系。
