---
ms.openlocfilehash: 6e78f9de8f21b6501e007e86f631942016f041dc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050590"
---
# <a name="jsbi--pure-javascript-bigints-build-statushttpstravis-cicomgooglechromelabsjsbi-jsbi-on-npmhttpswwwnpmjscompackagejsbi"></a>JSBI - pure-JavaScript BigInts [![生成状态](https://travis-ci.com/GoogleChromeLabs/jsbi.svg?branch=main)](https://travis-ci.com/GoogleChromeLabs/jsbi) [![jsbi on npm](https://img.shields.io/npm/v/jsbi)](https://www.npmjs.com/package/jsbi)

JSBI 是 [ECMAScript BigInt 提案](https://tc39.es/proposal-bigint/)的 pure-JavaScript 实现，它已正式成为 ES2020 中 JavaScript 语言的一部分。

## <a name="installation"></a>安装

```sh
npm install jsbi --save
```

## <a name="usage"></a>使用情况

```js
import JSBI from './jsbi.mjs';

const max = JSBI.BigInt(Number.MAX_SAFE_INTEGER);
console.log(String(max));
// → '9007199254740991'
const other = JSBI.BigInt('2');
const result = JSBI.add(max, other);
console.log(String(result));
// → '9007199254740993'
```

注意：在 `console.log()` 任何 `JSBI` 实例以查看其数字表示形式（例如 `String(max)` 或 `max.toString()`）时，请显式调用 `toString`。 如果没有它（例如 `console.log(max)`），你将看到表示值的对象。

使用 [babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) 将 JSBI 代码转换为本机 BigInt 代码。

有关详细信息，请参阅下面的详细说明。

## <a name="why"></a>为什么？

[本机 BigInts 已经在新式浏览器（在撰写本文时是指 Google Chrome 67+、Opera 54+、Firefox 68+）和 Node.js (v10.4+) 中发布](https://v8.dev/features/bigint)，并且预计它们将来会出现在其他浏览器中 - 这意味着如果你希望代码在任何地方运行，则还不能使用它们。

若要在代码中立即使用 BigInts，需要一个库。 但有一个难题：BigInt 提案改变了运算符（如 `+`、`>=` 等）在 BigInts 上的运行行为。 这些变化不可能直接进行 polyfill；而且它们还使得（在大多数情况下）使用 Babel 或类似工具将 BigInt 代码转译为回退代码变得不可行。 原因是，这种转译必须将程序中的每个运算符替换为对其输入执行类型检查的某个函数的调用，这将导致不可接受的性能损失。

解决方案是反过来操作：使用库的语法编写代码，并在可用时[将其转换为本机 BigInt 代码](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint)。 JSBI 正是为此目的而设计的：它提供了一个BigInt“polyfill”实现，其行为与即将推出的本机 BigInts 完全相同，但其语法可以在今天的所有浏览器上发布。

与其他现有的大整数库相比，它的优势是：

- 它的行为与本机 BigInts 在可用时的行为完全相同，因此要迁移到这些内容，你可以[机械地](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint)更新代码的语法；不需要重新思考其逻辑。
- 专注于性能。 平均而言，JSBI 与 Google Chrome 目前发布的本机实现相比具有性能竞争力。

## <a name="how"></a>如何操作？

除了语法上的机械差异之外，使用 JSBI-BigInts 就[像使用本机 BigInts 一样](https://developers.google.com/web/updates/2018/05/bigint)。 在将 `JSBI.BigInt` 替换 `BigInt` 之后，有些东西甚至看起来是一样的：

| 操作            | 本机 BigInts          | JSBI                     |
| -------------------- | ----------------------- | ------------------------ |
| 从字符串创建 | `a = BigInt('456')`     | `a = JSBI.BigInt('456')` |
| 从数字创建 | `a = BigInt(789)`       | `a = JSBI.BigInt(789)`   |
| 转换为字符串 | `a.toString(radix)`     | `a.toString(radix)`      |
| 转换为数字 | `Number(a)`             | `JSBI.toNumber(a)`       |
| 截断           | `BigInt.asIntN(64, a)`  | `JSBI.asIntN(64, a)`     |
|                      | `BigInt.asUintN(64, a)` | `JSBI.asUintN(64, a)`    |
| 类型检查           | `typeof a === 'bigint'` | `a instanceof JSBI`      |

大多数运算符都可被方法调用所取代：

| 操作                   | 本机 BigInts | JSBI                              |
| --------------------------- | -------------- | --------------------------------- |
| 加法                    | `c = a + b`    | `c = JSBI.add(a, b)`              |
| 减法                 | `c = a - b`    | `c = JSBI.subtract(a, b)`         |
| 乘法              | `c = a * b`    | `c = JSBI.multiply(a, b)`         |
| 除法                    | `c = a / b`    | `c = JSBI.divide(a, b)`           |
| 余数                   | `c = a % b`    | `c = JSBI.remainder(a, b)`        |
| 求幂              | `c = a ** b`   | `c = JSBI.exponentiate(a, b)`     |
| 否定                    | `b = -a`       | `b = JSBI.unaryMinus(a)`          |
| 按位求反            | `b = ~a`       | `b = JSBI.bitwiseNot(a)`          |
| 左移               | `c = a << b`   | `c = JSBI.leftShift(a, b)`        |
| 右移              | `c = a >> b`   | `c = JSBI.signedRightShift(a, b)` |
| 按位“和”               | `c = a & b`    | `c = JSBI.bitwiseAnd(a, b)`       |
| 按位“或”                | `c = a \| b`   | `c = JSBI.bitwiseOr(a, b)`        |
| 按位“异或”               | `c = a ^ b`    | `c = JSBI.bitwiseXor(a, b)`       |
| 与其他 BigInts 的比较 | `a === b`      | `JSBI.equal(a, b)`                |
|                             | `a !== b`      | `JSBI.notEqual(a, b)`             |
|                             | `a < b`        | `JSBI.lessThan(a, b)`             |
|                             | `a <= b`       | `JSBI.lessThanOrEqual(a, b)`      |
|                             | `a > b`        | `JSBI.greaterThan(a, b)`          |
|                             | `a >= b`       | `JSBI.greaterThanOrEqual(a, b)`   |

上述函数仅在 BigInts 上运行。 （它们在当前实现中不执行类型检查，因为当我们假设你知道自己正在执行的操作时，此类检查是在浪费时间。 不要尝试用其他输入调用它们，否则你会得到“有趣”的失败！）

它们提供混合类型的输入时，某些操作特别有趣，例如，将 BigInt 与数字进行比较，或者将字符串与 BigInt 连接起来。 它们作为以相应本机运算符命名的静态函数实现：

| 操作                       | 本机 BigInts | JSBI             |
| ------------------------------- | -------------- | ---------------- |
| 抽象相等比较    | `x == y`       | `JSBI.EQ(x, y)`  |
| 泛型“不等于”             | `x != y`       | `JSBI.NE(x, y)`  |
| 泛型“小于”             | `x < y`        | `JSBI.LT(x, y)`  |
| 泛型“小于等于”    | `x <= y`       | `JSBI.LE(x, y)`  |
| 泛型“大于”          | `x > y`        | `JSBI.GT(x, y)`  |
| 泛型“大于等于” | `x >= y`       | `JSBI.GE(x, y)`  |
| 泛型相加                | `x + y`        | `JSBI.ADD(x, y)` |

此处 `x` 和 `y` 变量名称指示变量可以引用任何内容，例如：`JSBI.GT(101.5, BigInt('100'))` 或 `str = JSBI.ADD('result: ', BigInt('0x2A'))`。

遗憾的是，还有一些根本不受支持的内容：

| 不支持的操作 | 本机 BigInts | JSBI                                 |
| --------------------- | -------------- | ------------------------------------ |
| 文本              | `a = 123n;`    | N/A ☹                                |
| 增量             | `a++`          | N/A ☹                                |
|                       | `a + 1n`       | `JSBI.add(a, JSBI.BigInt('1'))`      |
| 减量             | `a--`          | N/A ☹                                |
|                       | `a - 1n`       | `JSBI.subtract(a, JSBI.BigInt('1'))` |

不可能复制具有静态函数的本机 `++` 和 `--` 运算符的确切行为。 由于 JSBI 最终会被转译，因此它没有提供相似但不同的替代方案。 可以改用 `JSBI.add()` 和 `JSBI.subtract()`。

## <a name="when"></a>何时？

现在！ JSBI 库现已准备就绪，可供立即使用。

一旦 BigInts 在任何地方都得到了本机支持，请使用 [babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) 一次性地将 JSBI 代码转译为本机 BigInt 代码。

查看[我们的问题跟踪器](https://github.com/GoogleChromeLabs/jsbi/issues)以了解有关 JSBI 未来计划的更多信息，并请加入讨论！

一个更模糊的未来计划是使用 JSBI 库（或其扩展）作为其他 BigInt 相关功能的暂存地。 官方提案有意降低限度，并留下了更多“库函数”供后续提案使用。 示例包括组合 `exp`+`mod` 函数和位操作函数。

## <a name="development"></a>开发

1. 将此存储和 `cd` 克隆到本地目录。

1. 使用 `.nvmrc` 中指定的 Node.js 版本：

     ```sh
     nvm use
     ```

1. 安装开发依赖项：

    ```sh
    npm install
    ```

1. 运行测试：

    ```sh
    npm test
    ```

    有关命令列表，请参见 `npm run`。

## <a name="for-maintainers"></a>对于维护人员

### <a name="how-to-publish-a-new-release"></a>如何发布新版本

1. 在 `main` 分支上，在 `package.json` 中提升版本号：

    ```sh
    npm version patch -m 'Release v%s'
    ```

    不使用 `patch`，而是[根据需要](https://semver.org/)使用 `minor` 或 `major`。

    请注意，这将生成一个 Git 提交 + 标记。

1. 推送版本提交和标记：

    ```sh
    git push
    ```

    然后，CI 会自动将新版本发布到 npm。
