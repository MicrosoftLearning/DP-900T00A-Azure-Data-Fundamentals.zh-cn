---
ms.openlocfilehash: 496981207a34eb019688e8f2583ccc1abcbb5bce
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050178"
---
<a name="semver1----the-semantic-versioner-for-npm"></a>semver(1) -- npm 的语义版本程序
===========================================

## <a name="install"></a>安装

```bash
npm install --save semver
````

## <a name="usage"></a>使用情况

作为节点模块：

```js
const semver = require('semver')

semver.valid('1.2.3') // '1.2.3'
semver.valid('a.b.c') // null
semver.clean('  =v1.2.3   ') // '1.2.3'
semver.satisfies('1.2.3', '1.x || >=2.5.0 || 5.0.0 - 7.2.3') // true
semver.gt('1.2.3', '9.8.7') // false
semver.lt('1.2.3', '9.8.7') // true
semver.minVersion('>=1.0.0') // '1.0.0'
semver.valid(semver.coerce('v2')) // '2.0.0'
semver.valid(semver.coerce('42.6.7.9.3-alpha')) // '42.6.7'
```

作为命令行实用工具：

```
$ semver -h

A JavaScript implementation of the https://semver.org/ specification
Copyright Isaac Z. Schlueter

Usage: semver [options] <version> [<version> [...]]
Prints valid versions sorted by SemVer precedence

Options:
-r --range <range>
        Print versions that match the specified range.

-i --increment [<level>]
        Increment a version by the specified level.  Level can
        be one of: major, minor, patch, premajor, preminor,
        prepatch, or prerelease.  Default level is 'patch'.
        Only one version may be specified.

--preid <identifier>
        Identifier to be used to prefix premajor, preminor,
        prepatch or prerelease version increments.

-l --loose
        Interpret versions and ranges loosely

-p --include-prerelease
        Always include prerelease versions in range matching

-c --coerce
        Coerce a string into SemVer if possible
        (does not imply --loose)

Program exits successfully if any valid version satisfies
all supplied ranges, and prints all satisfying versions.

If no satisfying versions are found, then exits failure.

Versions are printed in ascending order, so supplying
multiple versions to the utility will just sort them.
```

## <a name="versions"></a>版本

有关“版本”的说明，请参阅 <https://semver.org/> 中的 `v2.0.0` 规范。

前导 `"="` 或 `"v"` 字符被剥离并忽略。

## <a name="ranges"></a>范围

`version range` 是一组 `comparators`，指定满足范围的版本。

`comparator` 由 `operator` 和 `version` 组成。  基元 `operators` 集为：

* `<` 小于
* `<=` 小于或等于
* `>` 大于
* `>=` 大于或等于
* `=` 等于。  如果未指定运算符，则假定相等性，因此此运算符是可选的，但可以包含。

例如，比较运算符 `>=1.2.7` 会匹配版本 `1.2.7`、`1.2.8`、`2.5.3` 和 `1.3.9`，但不会匹配版本 `1.2.6` 或 `1.1.0`。

比较运算符可以由空格联接，形成一个 `comparator set`，这由它包含的所有比较运算符的交集满足。

范围由一个或多个比较运算符集组成，通过 `||` 进行联接。  当且仅当其中至少一个 `||` 分隔的比较运算符集中的每个比较运算符满足版本时，版本与范围匹配。

例如，范围 `>=1.2.7 <1.3.0` 匹配版本 `1.2.7`、`1.2.8` 和 `1.2.99`，但不匹配版本 `1.2.6`、`1.3.0` 或 `1.1.0`。

范围 `1.2.7 || >=1.2.9 <2.0.0` 匹配版本 `1.2.7`、`1.2.9` 和 `1.4.6`，但不匹配版本 `1.2.8` 或 `2.0.0`。

### <a name="prerelease-tags"></a>预发布标记

如果版本有预发布标记（例如 `1.2.3-alpha.3`），则它将仅被允许满足比较运算符集（如果具有相同 `[major, minor, patch]` 元组的至少一个比较运算符也具有预发布标记）。

例如，范围 `>1.2.3-alpha.3` 会被允许匹配版本 `1.2.3-alpha.7`，但它不满足 `3.4.5-alpha.9`，即使根据 SemVer 分类规则 `3.4.5-alpha.9` 在理论上“大于”`1.2.3-alpha.3`。  版本范围仅接受 `1.2.3` 版本上的预发行标记。  版本 `3.4.5`  将满足范围，因为它没有预发布标记，且 `3.4.5` 大于 `1.2.3-alpha.7`。

此行为的目的是双重的。  首先，预发布版本通常很快更新，并包含（创建者设计的）尚不适合公众使用的许多中断性变更。
因此，默认情况下，它们从范围匹配语义中排除。

其次，选择使用预发布版本的用户清楚地指示了使用该特定 alpha/beta/rc 版本集的意图。  通过在范围内添加预发布标记，用户指示他们知道风险。  但是，仍不适合假设他们选择承担下一组预发布版本所带来的类似风险。

请注意，此行为可以被抑制（将所有预发布版本视为常规版本，出于范围匹配目的），方法是将选项对象上的 `includePrerelease` 标记设置为执行范围匹配的任何[函数](https://github.com/npm/node-semver#functions)。

#### <a name="prerelease-identifiers"></a>预发布标识符

方法 `.inc` 采用附加 `identifier` 字符串参数，该参数将字符串的值追加为预发布标识符：

```javascript
semver.inc('1.2.3', 'prerelease', 'beta')
// '1.2.4-beta.0'
```

命令行示例：

```bash
$ semver 1.2.3 -i prerelease --preid beta
1.2.4-beta.0
```

然后，可以使用它进一步递增：

```bash
$ semver 1.2.4-beta.0 -i prerelease
1.2.4-beta.1
```

### <a name="advanced-range-syntax"></a>高级范围语法

以确定性方式将高级范围语法脱糖为基元比较运算符。

可以通过与基元比较运算符相同的方式，使用空格或 `||` 合并高级范围。

#### <a name="hyphen-ranges-xyz---abc"></a>连字符范围 `X.Y.Z - A.B.C`

指定非独占集。

* `1.2.3 - 2.3.4` := `>=1.2.3 <=2.3.4`

如果部分版本作为非独占范围中的第一个版本提供，则缺失部分将替换为零。

* `1.2 - 2.3.4` := `>=1.2.0 <=2.3.4`

如果部分版本作为非独占范围中的第二个版本提供，则接受以元组提供部分开头的所有版本，但不会大于提供的元组部分。

* `1.2.3 - 2.3` := `>=1.2.3 <2.4.0`
* `1.2.3 - 2` := `>=1.2.3 <3.0.0`

#### <a name="x-ranges-12x-1x-12-"></a>X 范围 `1.2.x` `1.X` `1.2.*` `*`

任何 `X`、`x` 或 `*` 可用于代替 `[major, minor, patch]` 元组中的其中一个数值。

* `*` := `>=0.0.0`（任何版本满足）
* `1.x` := `>=1.0.0 <2.0.0`（匹配主版本）
* `1.2.x` := `>=1.2.0 <1.3.0`（匹配主版本和次要版本）

部分版本范围被视为 X 范围，因此特殊字符实际上是可选的。

* `""`（空字符串）:= `*` := `>=0.0.0`
* `1` := `1.x.x` := `>=1.0.0 <2.0.0`
* `1.2` := `1.2.x` := `>=1.2.0 <1.3.0`

#### <a name="tilde-ranges-123-12-1"></a>波形符范围 `~1.2.3``~1.2` `~1`

如果比较运算符上指定了次要版本，则允许修补级别更改。  如果不是，则允许进行次要级别的更改。

* `~1.2.3` := `>=1.2.3 <1.(2+1).0` := `>=1.2.3 <1.3.0`
* `~1.2` := `>=1.2.0 <1.(2+1).0` := `>=1.2.0 <1.3.0`（与 `1.2.x` 相同）
* `~1` := `>=1.0.0 <(1+1).0.0` := `>=1.0.0 <2.0.0`（与 `1.x` 相同）
* `~0.2.3` := `>=0.2.3 <0.(2+1).0` := `>=0.2.3 <0.3.0`
* `~0.2` := `>=0.2.0 <0.(2+1).0` := `>=0.2.0 <0.3.0`（与 `0.2.x` 相同）
* `~0` := `>=0.0.0 <(0+1).0.0` := `>=0.0.0 <1.0.0`（与 `0.x` 相同）
* `~1.2.3-beta.2` := `>=1.2.3-beta.2 <1.3.0` 请注意，如果 `1.2.3` 版本中的预发布大于或等于 `beta.2`，则允许它。  因此，`1.2.3-beta.4` 会被允许，但 `1.2.4-beta.2` 不被允许，因为它是其他 `[major, minor, patch]` 元组的预发布。

#### <a name="caret-ranges-123-025-004"></a>插入点范围 `^1.2.3` `^0.2.5` `^0.0.4`

允许不修改 `[major, minor, patch]` 元组中最左侧非零位的更改。  换句话说，这会允许版本 `1.0.0` 和更高版本的补丁和次要更新、版本 `0.X >=0.1.0` 的补丁更新，不允许版本 `0.0.X` 的更新。

许多创建者将 `0.x` 版本中的 `x` 视为主要“中断性变更”指示器。

如果创建者希望在 `0.2.4` 和 `0.3.0` 版本之间做出中断性变更，最好使用插入点范围，这是常见做法。
但是，它假设 `0.2.4` 和 `0.2.5` 之间没有中断性变更。  根据通常遵循的做法，它允许假设为添加（但非中断性）的更改。

* `^1.2.3` := `>=1.2.3 <2.0.0`
* `^0.2.3` := `>=0.2.3 <0.3.0`
* `^0.0.3` := `>=0.0.3 <0.0.4`
* `^1.2.3-beta.2` := `>=1.2.3-beta.2 <2.0.0` 请注意，如果 `1.2.3` 版本中的预发布大于或等于 `beta.2`，则允许它。  因此，`1.2.3-beta.4` 会被允许，但 `1.2.4-beta.2` 不被允许，因为它是其他 `[major, minor, patch]` 元组的预发布。
* `^0.0.3-beta` := `>=0.0.3-beta <0.0.4`  请注意，如果 `0.0.3` 版本中的预发布大于或等于 `beta`，则仅允许它。  因此，会允许 `0.0.3-pr.2`。

分析插入点范围时，缺失的 `patch` 值会脱糖为数字 `0`，但即使主版本和次要版本都是 `0`，也会允许该值内的灵活性。

* `^1.2.x` := `>=1.2.0 <2.0.0`
* `^0.0.x` := `>=0.0.0 <0.1.0`
* `^0.0` := `>=0.0.0 <0.1.0`

缺失的 `minor` 和 `patch` 值将脱糖为 0，但即使主版本为 0，也会允许这些值内的灵活性。

* `^1.x` := `>=1.0.0 <2.0.0`
* `^0.x` := `>=0.0.0 <1.0.0`

### <a name="range-grammar"></a>范围语法

将所有这一切放在一起，以下是范围的 Backus-Naur 语法，可供分析程序创建者利用：

```bnf
range-set  ::= range ( logical-or range ) *
logical-or ::= ( ' ' ) * '||' ( ' ' ) *
range      ::= hyphen | simple ( ' ' simple ) * | ''
hyphen     ::= partial ' - ' partial
simple     ::= primitive | partial | tilde | caret
primitive  ::= ( '<' | '>' | '>=' | '<=' | '=' ) partial
partial    ::= xr ( '.' xr ( '.' xr qualifier ? )? )?
xr         ::= 'x' | 'X' | '*' | nr
nr         ::= '0' | ['1'-'9'] ( ['0'-'9'] ) *
tilde      ::= '~' partial
caret      ::= '^' partial
qualifier  ::= ( '-' pre )? ( '+' build )?
pre        ::= parts
build      ::= parts
parts      ::= part ( '.' part ) *
part       ::= nr | [-0-9A-Za-z]+
```

## <a name="functions"></a>函数

所有方法和类都采用最终 `options` 对象参数。  默认情况下，此对象中的所有选项都是 `false`。  支持的选项包括：

- `loose`  对不太有效的 semver 字符串更宽容。
  （当然，任何生成的输出将始终 100% 严格合规。）出于后向兼容性原因，如果 `options` 参数是布尔值，而不是对象，则它被解释为 `loose` 参数。
- `includePrerelease`  设置为抑制范围中排除的预发布标记版本的[默认行为](https://github.com/npm/node-semver#prerelease-tags)，除非它们明确被选择加入。

严格模式比较运算符和范围会对它们分析的 SemVer 字符串要求非常严格。

* `valid(v)`：返回分析的版本；如果无效，则返回 null。
* `inc(v, release)`：返回通过版本类型（`major`、`premajor`、`minor`、`preminor`、`patch`、`prepatch` 或 `prerelease`）增加的版本；如果无效，则返回 null
  * 一次调用中的 `premajor` 会将版本增加到下一个主版本，具体到该主版本的预发布版本。
    `preminor` 和 `prepatch` 的工作方式是一样的。
  * 如果从非预发布版本调用，`prerelease` 的工作方式与 `prepatch` 相同。 它会增加补丁版本，然后创建预发布版本。 如果输入版本已是预发布版本，则只需递增它。
* `prerelease(v)`：返回预发布版本部分的数组；如果不存在，则返回 null。 示例： `prerelease('1.2.3-alpha.1') -> ['alpha', 1]`
* `major(v)`：返回主版本号。
* `minor(v)`：返回次要版本号。
* `patch(v)`：返回补丁版本号。
* `intersects(r1, r2, loose)`：如果两个提供的范围或比较运算符相交，则返回 true。
* `parse(v)`：尝试将字符串分析为语义版本，返回 `SemVer` 对象或 `null`。

### <a name="comparison"></a>比较

* `gt(v1, v2)`: `v1 > v2`
* `gte(v1, v2)`: `v1 >= v2`
* `lt(v1, v2)`: `v1 < v2`
* `lte(v1, v2)`: `v1 <= v2`
* `eq(v1, v2)`：`v1 == v2` 如果它们在逻辑上是等效的（即使它们不是完全相同的字符串），则为 true。  你已经知道如何比较字符串。
* `neq(v1, v2)`：`v1 != v2` 与 `eq` 相反。
* `cmp(v1, comparator, v2)`：传入比较字符串，它将调用上面的相应函数。  `"==="` 和 `"!=="` 执行简单的字符串比较，但出于完整性考虑包含在其中。  如果提供了无效的比较字符串，则引发。
* `compare(v1, v2)`：如果 `v1 == v2`，返回 `0`；如果 `v1` 更大，返回 `1`；如果 `v2` 更大，返回 `-1`。  如果传递给 `Array.sort()`，则按升序排序。
* `rcompare(v1, v2)`：比较的反转。  如果传递给 `Array.sort()`，则按降序对版本数组排序。
* `diff(v1, v2)`：按版本类型（`major`、`premajor`、`minor`、`preminor`、`patch`、`prepatch` 或 `prerelease`）返回两个版本的差；如果版本相同，返回 null。

### <a name="comparators"></a>比较

* `intersects(comparator)`：如果比较运算符相交，则返回 true

### <a name="ranges"></a>范围

* `validRange(range)`：返回有效范围；如果无效，返回 null
* `satisfies(version, range)`：如果版本满足范围，则返回 true。
* `maxSatisfying(versions, range)`：返回满足范围的列表中的最高版本；如果都不满足，则返回 `null`。
* `minSatisfying(versions, range)`：返回满足范围的列表中的最低版本；如果都不满足，则返回 `null`。
* `minVersion(range)`：返回可能与给定范围匹配的最低版本。
* `gtr(version, range)`：如果版本大于范围中可能的所有版本，则返回 `true`。
* `ltr(version, range)`：如果版本小于范围中可能的所有版本，则返回 `true`。
* `outside(version, range, hilo)`：如果版本超出高或低方向范围边界，则返回 true。  参数 `hilo` 必须是字符串 `'>'` 或 `'<'`。  （这是由 `gtr` 和 `ltr` 调用的函数。）
* `intersects(range)`：如果任何范围比较运算符相交，则返回 true

请注意，由于范围可能是非连续的，因此版本可能不大于范围、小于范围或满足范围！  例如，范围 `1.2 <1.2.9 || >2.0.0` 可能在 `1.2.9` 和 `2.0.0` 之间有一个孔，因此版本 `1.2.10` 可能不大于范围（因为 `2.0.1` 满足，该版本更高）、不小于范围（因为 `1.2.8` 满足，该版本更低），且它也不满足范围。

如果想知道某个版本是满足还是不满足某个范围，请使用 `satisfies(version, range)` 函数。

### <a name="coercion"></a>强制转换

* `coerce(version)`：如果可能，将字符串强制转换为 semver

这样做的目的是提供一种从非 semver 字符串到 semver 的非常宽容的转换。 它会查找字符串中的第一个数字，并使用满足至少一个部分 semver（如 `1`, `1.2``1.2.3`）的所有剩余字符，直到最大允许长度（256 个字符）。  较长的版本会被截断（`4.6.3.9.2-alpha2` 变为 `4.6.3`）。  所有周围的文本会被忽略（`v3.4 replaces v3.3.1` 变为 `3.4.0`）。  只有缺少数字的文本才无法强制转换（`version one` 无效）。  任何考虑进行强制转换的 semver 部分的最长长度为 16 个字符；更长的部分会被忽略（`10000000000000000.4.7.4` 变为 `4.7.4`）。  任何 semver 部分的最大值为 `Number.MAX_SAFE_INTEGER || (2**53 - 1)`；更大值部分无效（`9999999999999999.4.7.4` 可能无效）。
