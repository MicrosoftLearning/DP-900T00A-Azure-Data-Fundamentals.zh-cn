---
ms.openlocfilehash: 841a4ef811cc186a2302309fbbc4a380d1ba5cbd
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050176"
---
# <a name="tar-fs"></a>tar-fs

[tar-stream](https://github.com/mafintosh/tar-stream) 的文件系统绑定。

```
npm install tar-fs
```

[![生成状态](https://secure.travis-ci.org/mafintosh/tar-fs.png)](http://travis-ci.org/mafintosh/tar-fs)

## <a name="usage"></a>使用情况

tar-fs 允许将目录打包到 tarball 中，并将 tarball 提取到目录中。

它不会为你解压缩，因此如果你想用它提取 `.tar.gz`，除此之外，还需要使用 [gunzip-maybe](https://github.com/mafintosh/gunzip-maybe) 之类的工具。

``` js
var tar = require('tar-fs')
var fs = require('fs')

// packing a directory
tar.pack('./my-directory').pipe(fs.createWriteStream('my-tarball.tar'))

// extracting a directory
fs.createReadStream('my-other-tarball.tar').pipe(tar.extract('./my-other-directory'))
```

如需在打包或提取时忽略各种文件，可以将 ignore 函数添加到选项。 `ignore` 也是 `filter` 的别名。 此外，如果你在提取时使用 ignore，则会得到 `header`。
这样，还可以按元数据进行筛选。

``` js
var pack = tar.pack('./my-directory', {
  ignore: function(name) {
    return path.extname(name) === '.bin' // ignore .bin files when packing
  }
})

var extract = tar.extract('./my-other-directory', {
  ignore: function(name) {
    return path.extname(name) === '.bin' // ignore .bin files inside the tarball when extracing
  }
})

var extractFilesDirs = tar.extract('./my-other-other-directory', {
  ignore: function(_, header) {
    // pass files & directories, ignore e.g. symlinks
    return header.type !== 'file' && header.type !== 'directory'
  }
})
```

还可以使用 `entries` 选项指定要打包的条目

```js
var pack = tar.pack('./my-directory', {
  entries: ['file1', 'subdir/file2'] // only the specific entries will be packed
})
```

如果要在打包/提取时修改标头，请将 map 函数添加到选项

``` js
var pack = tar.pack('./my-directory', {
  map: function(header) {
    header.name = 'prefixed/'+header.name
    return header
  }
})

var extract = tar.extract('./my-directory', {
  map: function(header) {
    header.name = 'another-prefix/'+header.name
    return header
  }
})
```

同样，如果你想修改输入/输出文件流，可以使用 `mapStream`

``` js
var pack = tar.pack('./my-directory', {
  mapStream: function(fileStream, header) {
    // NOTE: the returned stream HAS to have the same length as the input stream.
    // If not make sure to update the size in the header passed in here.
    if (path.extname(header.name) === '.js') {
      return fileStream.pipe(someTransform)
    }
    return fileStream;
  }
})

var extract = tar.extract('./my-directory', {
  mapStream: function(fileStream, header) {
    if (path.extname(header.name) === '.js') {
      return fileStream.pipe(someTransform)
    }
    return fileStream;
  }
})
```

设置 `options.fmode` 和 `options.dmode` 以确保提取的文件/目录具有相应的模式

``` js
var extract = tar.extract('./my-directory', {
  dmode: parseInt(555, 8), // all dirs should be readable
  fmode: parseInt(444, 8) // all files should be readable
})
```

如果你要在 *nix/windows 之间打包/解包 tarball，则使用 `dmode` 和 `fmode` 会很有用，这样可以确保解包的所有文件/目录都是可读的。

或者，你可以设置 `options.readable` 和/或 `options.writable`，以将 dmode 和 fmode 设置为可读取/可写入。

``` js
var extract = tar.extract('./my-directory', {
  readable: true, // all dirs and files should be readable
  writable: true, // all dirs and files should be writable
})
```

如果希望忽略由于不支持的条目类型（如设备文件）导致的错误，则将 `options.strict` 设置为 `false`

若要取消引用符号链接（打包符号链接的内容而不是链接本身），请将 `options.dereference` 设置为 `true`。

## <a name="copy-a-directory"></a>复制目录

复制具有完整权限和 mtime 的目录就像

``` js
tar.pack('source-directory').pipe(tar.extract('dest-directory'))
```

## <a name="interaction-with-tar-stream"></a>与 [`tar-stream`](https://github.com/mafintosh/tar-stream) 交互一样简单

使用 `finalize: false` 和 `finish` 挂钩使包流保持打开状态以供进一步输入（请参阅 [`tar-stream#pack`](https://github.com/mafintosh/tar-stream#packing)），并使用 `pack` 传递现有的包流。

``` js
var mypack = tar.pack('./my-directory', {
  finalize: false,
  finish: function(sameAsMypack) {
    mypack.entry({name: 'generated-file.txt'}, "hello")
    tar.pack('./other-directory', {
      pack: sameAsMypack
    })
  }
})
```


## <a name="performance"></a>性能

打包并提取 6.1 GB 的 2496 个目录和 2398 个文件会在我的 Macbook Air 上生成以下结果。
[在此处查看基准](https://gist.github.com/mafintosh/8102201)

* tar-fs：34.261 秒
* [node-tar](https://github.com/isaacs/node-tar):366.123 秒（或慢 10 倍）

## <a name="license"></a>许可

MIT
