---
ms.openlocfilehash: bd96d4c9278b37a2a3626abd3bd91dd20a15e2e1
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050913"
---
<a name="https-proxy-agent"></a>https-proxy-agent
================
### <a name="an-https-proxy-httpagent-implementation-for-https"></a>适用于 HTTP 的 HTTP(s) 代理 `http.Agent` 实现
[![生成状态](https://github.com/TooTallNate/node-https-proxy-agent/workflows/Node%20CI/badge.svg)](https://github.com/TooTallNate/node-https-proxy-agent/actions?workflow=Node+CI)

此模块提供连接到指定 HTTP 或 HTTPS 代理服务器的 `http.Agent` 实现，可与内置 `https` 模块一起使用。

具体而言，此 `Agent` 实现连接到中间的“代理”服务器并发出 [CONNECT HTTP 方法][CONNECT]，该方法告知代理打开与目标服务器的直接 TCP 连接。

由于此代理实现了 CONNECT HTTP 方法，因此它适用于通过代理（即 WebSocket）进行连接时使用此方法的其他协议。
请参阅以下“示例”部分了解详细信息。


<a name="installation"></a>安装
------------

使用 `npm` 进行安装：

``` bash
$ npm install https-proxy-agent
```


<a name="examples"></a>示例
--------

#### <a name="https-module-example"></a>`https` 模块示例

``` js
var url = require('url');
var https = require('https');
var HttpsProxyAgent = require('https-proxy-agent');

// HTTP/HTTPS proxy to connect to
var proxy = process.env.http_proxy || 'http://168.63.76.32:3128';
console.log('using proxy server %j', proxy);

// HTTPS endpoint for the proxy to connect to
var endpoint = process.argv[2] || 'https://graph.facebook.com/tootallnate';
console.log('attempting to GET %j', endpoint);
var options = url.parse(endpoint);

// create an instance of the `HttpsProxyAgent` class with the proxy server information
var agent = new HttpsProxyAgent(proxy);
options.agent = agent;

https.get(options, function (res) {
  console.log('"response" event!', res.headers);
  res.pipe(process.stdout);
});
```

#### <a name="ws-websocket-connection-example"></a>`ws` WebSocket 连接示例

``` js
var url = require('url');
var WebSocket = require('ws');
var HttpsProxyAgent = require('https-proxy-agent');

// HTTP/HTTPS proxy to connect to
var proxy = process.env.http_proxy || 'http://168.63.76.32:3128';
console.log('using proxy server %j', proxy);

// WebSocket endpoint for the proxy to connect to
var endpoint = process.argv[2] || 'ws://echo.websocket.org';
var parsed = url.parse(endpoint);
console.log('attempting to connect to WebSocket %j', endpoint);

// create an instance of the `HttpsProxyAgent` class with the proxy server information
var options = url.parse(proxy);

var agent = new HttpsProxyAgent(options);

// finally, initiate the WebSocket connection
var socket = new WebSocket(endpoint, { agent: agent });

socket.on('open', function () {
  console.log('"open" event!');
  socket.send('hello world');
});

socket.on('message', function (data, flags) {
  console.log('"message" event! %j %j', data, flags);
  socket.close();
});
```

<a name="api"></a>API
---

### <a name="new-httpsproxyagentobject-options"></a>新的 HttpsProxyAgent（对象选项）

`HttpsProxyAgent` 类实现一个 `http.Agent` 子类，该子类连接到指定的“HTTP(s) 代理服务器"，以便代理 HTTPS 和/或 WebSocket 请求。 这通过使用 [HTTP `CONNECT` 方法][CONNECT]实现。

`options` 参数可以是要使用的代理服务器的字符串 URI，也可以是具有更具体属性的”options“对象：

  * `host` - 字符串 - 要连接到的代理主机（也可以使用 `hostname`）。 必需。
  * `port` - 数字 - 要连接到的代理端口。 必需。
  * `protocol` - 字符串 - 如果为 `https:`，则使用 TLS 连接到代理。
  * `headers` - 对象 - 要发送到 HTTP CONNECT 方法的其他 HTTP 标头。
  * 提供的任何其他选项都传递给 `net.connect()`/`tls.connect()` 函数。


<a name="license"></a>许可
-------

（MIT 许可证）

版权所有 (c) 2013 Nathan Rajlich &lt;nathan@tootallnate.net&gt;

特此免费授予获得该软件和相关文档文件（“软件”）副本的任何人无限制地处理软件的权利，包括但不限于使用、复制、修改、合并、发布、分发、再许可和/或出售本软件的副本，并允许提供软件的人员这样做，但须满足以下条件：

The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.

本软件按“原样”提供，不提供任何形式的明示或暗示担保，包括但不限于对适销性，特定目的的适用性和非侵权性的担保。
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

[CONNECT]: http://en.wikipedia.org/wiki/HTTP_tunnel#HTTP_CONNECT_Tunneling
