---
ms.openlocfilehash: 4f70d9e1d8895757244ec8464f178ff3068a36bd
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050509"
---
# <a name="rc"></a>rc

为懒人准备的不可配置的配置加载器。

## <a name="usage"></a>使用情况

唯一的方法是把将你的应用名称和默认配置传递给 rc。

```javascript
var conf = require('rc')(appname, {
  //defaults go here.
  port: 2468,

  //defaults which are objects will be merged, not replaced
  views: {
    engine: 'jade'
  }
});
```

`rc` 将返回与指定的默认值合并的配置选项。
如果传入预定义的默认值对象，它将改变为：

```javascript
var conf = {};
require('rc')(appname, conf);
```

如果 `rc` 找到应用的任何配置文件，则返回的配置对象将有一个包含其路径的 `configs` 数组：

```javascript
var appCfg = require('rc')(appname, conf);
appCfg.configs[0] // /etc/appnamerc
appCfg.configs[1] // /home/dominictarr/.config/appname
appCfg.config // same as appCfg.configs[appCfg.configs.length - 1]
```

## <a name="standards"></a>标准

给定应用程序名称 (`appname`) 后，rc 将在所有明显的位置寻找配置。

  * 命令行参数，由 minimist 解析（例如 `--foo baz`，也可以嵌套成：`--foo.bar=baz`）
  * 前缀为 `${appname}_` 的环境变量
    * 或使用“\_\_”指示嵌套属性 <br/> （例如，`appname_foo__bar__baz` => `foo.bar.baz`）
  * 如果传递了一个选项 `--config file` 文件，则从该文件查找
  * 本地 `.${appname}rc` 或在 `./ ../ ../../ ../../../` 等中找到的第一个。
  * `$HOME/.${appname}rc`
  * `$HOME/.${appname}/config`
  * `$HOME/.config/${appname}`
  * `$HOME/.config/${appname}/config`
  * `/etc/${appname}rc`
  * `/etc/${appname}/config`
  * 传入的默认对象。

找到的所有配置源都将平展为一个对象，以便此列表中前面的源替代后面的源。


## <a name="configuration-file-formats"></a>配置文件格式

配置文件（例如 `.appnamerc`）可以是 [json](http://json.org/example) 或 [ini](http://en.wikipedia.org/wiki/INI_file) 格式。 不应使用文件扩展名（`.json` 或 `.ini`）。 下面的示例配置是等效的：


#### <a name="formatted-as-ini"></a>格式设置为 `ini`

```
; You can include comments in `ini` format if you want.

dependsOn=0.10.0


; `rc` has built-in support for ini sections, see?

[commands]
  www     = ./commands/www
  console = ./commands/repl


; You can even do nested sections

[generators.options]
  engine  = ejs

[generators.modules]
  new     = generate-new
  engine  = generate-backend

```

#### <a name="formatted-as-json"></a>格式设置为 `json`

```javascript
{
  // You can even comment your JSON, if you want
  "dependsOn": "0.10.0",
  "commands": {
    "www": "./commands/www",
    "console": "./commands/repl"
  },
  "generators": {
    "options": {
      "engine": "ejs"
    },
    "modules": {
      "new": "generate-new",
      "backend": "generate-backend"
    }
  }
}
```

注释通过 [strip-json-comments](https://github.com/sindresorhus/strip-json-comments) 从 JSON 配置中去除。

> 由于 ini 和 env 变量没有类型标准，因此为在字符串中使用需准备好应用程序。

为确保布尔值和数字的字符串表示形式始终转换为正确的类型（在计划进行严格的 `===` 比较时特别有用），请考虑使用 [parse-strings-in-object](https://github.com/anselanza/parse-strings-in-object) 之类的模块来包装从 rc 返回的配置对象。


## <a name="simple-example-demonstrating-precedence"></a>演示优先级的简单示例
假设有一个如下所示的应用程序（注意传递给 rc 的硬编码默认值）：
```
const conf = require('rc')('myapp', {
    port: 12345,
    mode: 'test'
});

console.log(JSON.stringify(conf, null, 2));
```
你还有一个文件 `config.json`，其中包含以下内容：
```
{
  "port": 9000,
  "foo": "from config json",
  "something": "else"
}
```
还有一个在同一文件夹中的文件 `.myapprc`，其中包含以下内容：
```
{
  "port": "3001",
  "foo": "bar"
}
```
下面是各种命令的预期输出：

`node .`
```
{
  "port": "3001",
  "mode": "test",
  "foo": "bar",
  "_": [],
  "configs": [
    "/Users/stephen/repos/conftest/.myapprc"
  ],
  "config": "/Users/stephen/repos/conftest/.myapprc"
}
```
保留了硬编码对象的默认 `mode`，但将端口替代为 `.myapprc` 文件（根据 appname 匹配自动找到），并添加了 `foo`。


`node . --foo baz`
```
{
  "port": "3001",
  "mode": "test",
  "foo": "baz",
  "_": [],
  "configs": [
    "/Users/stephen/repos/conftest/.myapprc"
  ],
  "config": "/Users/stephen/repos/conftest/.myapprc"
}
```
结果与上面相同，但 `foo` 被替代，因为命令行参数优先于 `.myapprc` 文件。

`node . --foo barbar --config config.json`
```
{
  "port": 9000,
  "mode": "test",
  "foo": "barbar",
  "something": "else",
  "_": [],
  "config": "config.json",
  "configs": [
    "/Users/stephen/repos/conftest/.myapprc",
    "config.json"
  ]
}
```
现在 `port` 来自指定的 `config.json` 文件（替代 `.myapprc` 中的值），并且命令行替代了 `foo` 值，尽管它也在 `config.json` 文件中指定。
 


## <a name="advanced-usage"></a>高级用法

#### <a name="pass-in-your-own-argv"></a>传入自己的 `argv`

可以传入自己的 `argv` 作为 `rc` 的第三个参数。  这是为了以防你想[使用自己的命令行 opts 解析器](https://github.com/dominictarr/rc/pull/12)。

```javascript
require('rc')(appname, defaults, customArgvParser);
```

## <a name="pass-in-your-own-parser"></a>传入自己的分析器

如果情况特殊需使用非标准解析器，可通过将解析器作为第四个参数传入来实现。
（将第三个参数保留为 null，以获取默认参数分析器）

```javascript
require('rc')(appname, defaults, null, parser);
```

这也可用于强制采用更严格的格式，例如仅使用严格、有效的 JSON。

## <a name="note-on-performance"></a>性能说明

`rc` 正在运行 `fs.statSync`，因此请确保不要在热代码路径（例如请求处理程序）中使用它 


## <a name="license"></a>许可

获得双条款的 BSD 许可证、MIT 许可证或 Apache 许可证 2.0 版的多重许可
