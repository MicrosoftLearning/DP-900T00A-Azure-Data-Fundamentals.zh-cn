---
ms.openlocfilehash: 79b8bd5d8af7fd6d79dcb7c24b3f2e03e1d2a029
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050793"
---
# <a name="ansi-regex-build-statushttpstravis-ciorgchalkansi-regex"></a>ansi-regex [![生成状态](https://travis-ci.org/chalk/ansi-regex.svg?branch=master)](https://travis-ci.org/chalk/ansi-regex)

> 匹配 [ANSI 转义代码](http://en.wikipedia.org/wiki/ANSI_escape_code)的正则表达式


## <a name="install"></a>安装

```
$ npm install --save ansi-regex
```


## <a name="usage"></a>使用情况

```js
const ansiRegex = require('ansi-regex');

ansiRegex().test('\u001b[4mcake\u001b[0m');
//=> true

ansiRegex().test('cake');
//=> false

'\u001b[4mcake\u001b[0m'.match(ansiRegex());
//=> ['\u001b[4m', '\u001b[0m']
```

## <a name="faq"></a>常见问题解答

### <a name="why-do-you-test-for-codes-not-in-the-ecma-48-standard"></a>为什么测试不在 ECMA 48 标准中的代码？

我们作为测试运行的一些代码是我们在查找非标准代码或制造商特定代码的各种列表时获得的代码。 如果我没记错的话，我们既会测试标准代码，也会测试非标准代码，因为它们中的大多数遵循相同或相似的格式，可以安全地在字符串中匹配，而不会有删除实际字符串内容的风险。 有几个非标准控制代码不遵循传统格式（即它们以数字结尾），因而迫使我们将它们排除在测试之外，因为我们无法可靠地匹配它们。

从历史角度来看，这些 ECMA 标准是在 90 年代初建立的，而 VT100 则是在 70 年代中/后期设计的。 当时，控制代码还很不受控制，工程师使用这些代码进行多种操作，即激活可能已有专有用途的硬件端口。 在其他地方，你会看到处理器的 x86 体系结构中也有类似的“无秩序”代码；在某些品牌的处理器（其中大多数已经逐步淘汰）上有大量“中断”，它们可能意味着不同的事情。


## <a name="license"></a>许可

MIT © [Sindre Sorhus](http://sindresorhus.com)
