---
ms.openlocfilehash: 334cc21b44dad92ee91fd1f8a2aaf91f242cea2e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050861"
---
# <a name="qs-supversion-badge21sup"></a>qs <sup>[![版本徽章][2]][1]</sup>

[![生成状态][3]][4]
[![依赖项状态][5]][6]
[![开发依赖项状态][7]][8]
[![许可证][license-image]][license-url]
[![下载][downloads-image]][downloads-url]

[![npm 徽章][11]][1]

增加了安全性的查询字符串分析和字符串化库。

维护负责人：[Jordan Harband](https://github.com/ljharb)

qs 模块最初由 [TJ Holowaychuk](https://github.com/visionmedia/node-querystring) 创建和维护。

## <a name="usage"></a>使用情况

```javascript
var qs = require('qs');
var assert = require('assert');

var obj = qs.parse('a=c');
assert.deepEqual(obj, { a: 'c' });

var str = qs.stringify(obj);
assert.equal(str, 'a=c');
```

### <a name="parsing-objects"></a>分析对象

[](#preventEval)
```javascript
qs.parse(string, [options]);
```

通过 qs 可以在查询字符串中创建嵌套对象，方法是将子键的名称用方括号 `[]` 括起来。
例如，字符串 `'foo[bar]=baz'` 转换为：

```javascript
assert.deepEqual(qs.parse('foo[bar]=baz'), {
    foo: {
        bar: 'baz'
    }
});
```

使用 `plainObjects` 选项时，分析值作为 null 对象返回，通过 `Object.create(null)` 创建，因此应注意原型方法将不存在于其中，用户可将这些名称设置为他们喜欢的任何值：

```javascript
var nullObject = qs.parse('a[hasOwnProperty]=b', { plainObjects: true });
assert.deepEqual(nullObject, { a: { hasOwnProperty: 'b' } });
```

默认情况下，会覆盖对象原型上的属性的参数将被忽略，如果希望保留这些字段中的数据，可以使用上面提到的 `plainObjects`，或者将 `allowPrototypes` 设置为 `true`，这将允许用户输入覆盖这些属性。 警告：启用此选项通常不是一个好主意，因为尝试使用已覆盖的属性时可能会导致问题。 请始终谨慎使用此选项。

```javascript
var protoObject = qs.parse('a[hasOwnProperty]=b', { allowPrototypes: true });
assert.deepEqual(protoObject, { a: { hasOwnProperty: 'b' } });
```

URI 编码的字符串也适用：

```javascript
assert.deepEqual(qs.parse('a%5Bb%5D=c'), {
    a: { b: 'c' }
});
```

还可以嵌套对象，例如 `'foo[bar][baz]=foobarbaz'`：

```javascript
assert.deepEqual(qs.parse('foo[bar][baz]=foobarbaz'), {
    foo: {
        bar: {
            baz: 'foobarbaz'
        }
    }
});
```

默认情况下，嵌套对象时，qs 最多分析 5 个子级深度。 这意味着，如果尝试分析像 `'a[b][c][d][e][f][g][h][i]=j'` 这样的字符串，生成的对象将是：

```javascript
var expected = {
    a: {
        b: {
            c: {
                d: {
                    e: {
                        f: {
                            '[g][h][i]': 'j'
                        }
                    }
                }
            }
        }
    }
};
var string = 'a[b][c][d][e][f][g][h][i]=j';
assert.deepEqual(qs.parse(string), expected);
```

可以通过将 `depth` 选项传递给 `qs.parse(string, [options])` 来重写此深度：

```javascript
var deep = qs.parse('a[b][c][d][e][f][g][h][i]=j', { depth: 1 });
assert.deepEqual(deep, { a: { b: { '[c][d][e][f][g][h][i]': 'j' } } });
```

当 qs 用于分析用户输入时，深度限制有助于缓解滥用，建议将其保留为尽可能小的合理数字。

因此，默认情况下，qs 最多分析 1000 个参数。 可以通过传递 `parameterLimit` 选项进行重写：

```javascript
var limited = qs.parse('a=b&c=d', { parameterLimit: 1 });
assert.deepEqual(limited, { a: 'b' });
```

若要绕过前导问号，请使用 `ignoreQueryPrefix`：

```javascript
var prefixed = qs.parse('?a=b&c=d', { ignoreQueryPrefix: true });
assert.deepEqual(prefixed, { a: 'b', c: 'd' });
```

还可以传递可选的分隔符：

```javascript
var delimited = qs.parse('a=b;c=d', { delimiter: ';' });
assert.deepEqual(delimited, { a: 'b', c: 'd' });
```

分隔符也可以是一个正则表达式：

```javascript
var regexed = qs.parse('a=b;c=d,e=f', { delimiter: /[;,]/ });
assert.deepEqual(regexed, { a: 'b', c: 'd', e: 'f' });
```

选项 `allowDots` 可用于启用点表示法：

```javascript
var withDots = qs.parse('a.b=c', { allowDots: true });
assert.deepEqual(withDots, { a: { b: 'c' } });
```

如果必须处理旧浏览器或服务，还支持将百分比编码八进制数解码为 iso-8859-1：

```javascript
var oldCharset = qs.parse('a=%A7', { charset: 'iso-8859-1' });
assert.deepEqual(oldCharset, { a: '§' });
```

某些服务向表单添加初始 `utf8=✓` 值，以便旧版 Internet Explorer 更有可能将表单提交为 utf-8。 此外，服务器还可以根据复选标记字符的错误编码检查值，并检测查询字符串或 `application/x-www-form-urlencoded` 正文是否未作为 utf-8 发送，例如， 如果表单具有 `accept-charset` 参数或包含页具有其他字符集。

qs 通过 `charsetSentinel` 选项支持此机制。
如果指定，将从返回的对象中省略 `utf8` 参数。 它将用于切换到 `iso-8859-1`/`utf-8` 模式，具体取决于复选标记的编码方式。

**重要说明**：同时指定 `charset` 选项和 `charsetSentinel` 选项时，如果请求包含可从中推断实际字符集的 `utf8` 参数，将重写 `charset`。 从这个意义上说，`charset` 将充当默认字符集，而不是权威字符集。

```javascript
var detectedAsUtf8 = qs.parse('utf8=%E2%9C%93&a=%C3%B8', {
    charset: 'iso-8859-1',
    charsetSentinel: true
});
assert.deepEqual(detectedAsUtf8, { a: 'ø' });

// Browsers encode the checkmark as &#10003; when submitting as iso-8859-1:
var detectedAsIso8859_1 = qs.parse('utf8=%26%2310003%3B&a=%F8', {
    charset: 'utf-8',
    charsetSentinel: true
});
assert.deepEqual(detectedAsIso8859_1, { a: 'ø' });
```

如果要将 `&#...;` 语法解码为实际字符，还可以指定 `interpretNumericEntities` 选项：

```javascript
var detectedAsIso8859_1 = qs.parse('a=%26%239786%3B', {
    charset: 'iso-8859-1',
    interpretNumericEntities: true
});
assert.deepEqual(detectedAsIso8859_1, { a: '☺' });
```

在 `charsetSentinel` 模式中检测到字符集时，它也有效。

### <a name="parsing-arrays"></a>分析数组

qs 还可以使用类似的 `[]` 表示法分析数组：

```javascript
var withArray = qs.parse('a[]=b&a[]=c');
assert.deepEqual(withArray, { a: ['b', 'c'] });
```

还可以指定索引：

```javascript
var withIndexes = qs.parse('a[1]=c&a[0]=b');
assert.deepEqual(withIndexes, { a: ['b', 'c'] });
```

请注意，数组中的索引与对象中的键之间的唯一区别是括号之间的值必须是数字才能创建数组。 使用特定索引创建数组时，qs 会将稀疏数组压缩为仅保留其顺序的现有值：

```javascript
var noSparse = qs.parse('a[1]=b&a[15]=c');
assert.deepEqual(noSparse, { a: ['b', 'c'] });
```

还可以使用 `allowSparse` 选项分析稀疏数组：

```javascript
var sparseArray = qs.parse('a[1]=2&a[3]=5', { allowSparse: true });
assert.deepEqual(sparseArray, { a: [, '2', , '5'] });
```

请注意，空字符串也是一个值，并将保留：

```javascript
var withEmptyString = qs.parse('a[]=&a[]=b');
assert.deepEqual(withEmptyString, { a: ['', 'b'] });

var withIndexedEmptyString = qs.parse('a[0]=b&a[1]=&a[2]=c');
assert.deepEqual(withIndexedEmptyString, { a: ['b', '', 'c'] });
```

qs 还将数组中的指定索引限制为最大索引 `20`。 任何索引大于 `20` 的数组成员都将转换为以索引为键的对象。 如果有人发送如 `a[999999999]` 并且需要花费大量时间来循环访问这个巨大的数组，则需要此操作来处理这种情况。

```javascript
var withMaxIndex = qs.parse('a[100]=b');
assert.deepEqual(withMaxIndex, { a: { '100': 'b' } });
```

可以通过传递 `arrayLimit` 选项来重写此限制：

```javascript
var withArrayLimit = qs.parse('a[1]=b', { arrayLimit: 0 });
assert.deepEqual(withArrayLimit, { a: { '1': 'b' } });
```

若要完全禁用数组分析，请将 `parseArrays` 设置为 `false`。

```javascript
var noParsingArrays = qs.parse('a[]=b', { parseArrays: false });
assert.deepEqual(noParsingArrays, { a: { '0': 'b' } });
```

如果混合表示法，qs 会将这两项合并到一个对象中：

```javascript
var mixedNotation = qs.parse('a[0]=b&a[b]=c');
assert.deepEqual(mixedNotation, { a: { '0': 'b', b: 'c' } });
```

还可以创建对象数组：

```javascript
var arraysOfObjects = qs.parse('a[][b]=c');
assert.deepEqual(arraysOfObjects, { a: [{ b: 'c' }] });
```

有些人使用逗号联接数组，qs 可以分析它：
```javascript
var arraysOfObjects = qs.parse('a=b,c', { comma: true })
assert.deepEqual(arraysOfObjects, { a: ['b', 'c'] })
```
（这无法转换嵌套对象，例如 `a={b:1},{c:d}`）

### <a name="stringifying"></a>字符串化

[](#preventEval)
```javascript
qs.stringify(object, [options]);
```

字符串化时，qs 默认 URI 对输出进行编码。 对象按预期进行字符串化：

```javascript
assert.equal(qs.stringify({ a: 'b' }), 'a=b');
assert.equal(qs.stringify({ a: { b: 'c' } }), 'a%5Bb%5D=c');
```

可以通过将 `encode` 选项设置为 `false` 来禁用此编码：

```javascript
var unencoded = qs.stringify({ a: { b: 'c' } }, { encode: false });
assert.equal(unencoded, 'a[b]=c');
```

通过将 `encodeValuesOnly` 选项设置为 `true`，可以禁用键的编码：
```javascript
var encodedValues = qs.stringify(
    { a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] },
    { encodeValuesOnly: true }
);
assert.equal(encodedValues,'a=b&c[0]=d&c[1]=e%3Df&f[0][0]=g&f[1][0]=h');
```

此编码也可以由设置为 `encoder` 选项的自定义编码方法替换：

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str) {
    // Passed in values `a`, `b`, `c`
    return // Return encoded string
}})
```

（注意：如果 `encode` 为 `false`，则 `encoder` 选项不适用）

与 `encoder` 类似，`parse` 有一个 `decoder` 选项来重写属性和值的解码：

```javascript
var decoded = qs.parse('x=z', { decoder: function (str) {
    // Passed in values `x`, `z`
    return // Return decoded string
}})
```

可以使用提供给编码器的类型参数使用不同的逻辑对键和值进行编码：

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str, defaultEncoder, charset, type) {
    if (type === 'key') {
        return // Encoded key
    } else if (type === 'value') {
        return // Encoded value
    }
}})
```

还会向解码器提供类型参数：

```javascript
var decoded = qs.parse('x=z', { decoder: function (str, defaultDecoder, charset, type) {
    if (type === 'key') {
        return // Decoded key
    } else if (type === 'value') {
        return // Decoded value
    }
}})
```

为清楚起见，超出此点的示例将显示为输出未进行 URI 编码。 请注意，在这些情况下，返回值将在实际使用期间进行 URI 编码。

当数组被字符串化时，默认情况下为它们提供显式索引：

```javascript
qs.stringify({ a: ['b', 'c', 'd'] });
// 'a[0]=b&a[1]=c&a[2]=d'
```

可以通过将 `indices` 选项设置为 `false` 进行重写：

```javascript
qs.stringify({ a: ['b', 'c', 'd'] }, { indices: false });
// 'a=b&a=c&a=d'
```

可以使用 `arrayFormat` 选项指定输出数组的格式：

```javascript
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'indices' })
// 'a[0]=b&a[1]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'brackets' })
// 'a[]=b&a[]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'repeat' })
// 'a=b&a=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'comma' })
// 'a=b,c'
```

当对象被字符串化时，默认情况下，它们使用括号表示法：

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } });
// 'a[b][c]=d&a[b][e]=f'
```

可以通过将 `allowDots` 选项设置为 `true` 进行重写以使用点表示法：

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } }, { allowDots: true });
// 'a.b.c=d&a.b.e=f'
```

空字符串和 null 值将省略该值，但等号 (=) 保持不变：

```javascript
assert.equal(qs.stringify({ a: '' }), 'a=');
```

没有值的键（如空对象或数组）将不返回任何内容：

```javascript
assert.equal(qs.stringify({ a: [] }), '');
assert.equal(qs.stringify({ a: {} }), '');
assert.equal(qs.stringify({ a: [{}] }), '');
assert.equal(qs.stringify({ a: { b: []} }), '');
assert.equal(qs.stringify({ a: { b: {}} }), '');
```

将完全省略设置为 `undefined` 的属性：

```javascript
assert.equal(qs.stringify({ a: null, b: undefined }), 'a=');
```

可以选择在查询字符串前面加上问号：

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { addQueryPrefix: true }), '?a=b&c=d');
```

还可以通过字符串化重写分隔符：

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { delimiter: ';' }), 'a=b;c=d');
```

如果只想重写 `Date` 对象的序列化，可以提供一个 `serializeDate` 选项：

```javascript
var date = new Date(7);
assert.equal(qs.stringify({ a: date }), 'a=1970-01-01T00:00:00.007Z'.replace(/:/g, '%3A'));
assert.equal(
    qs.stringify({ a: date }, { serializeDate: function (d) { return d.getTime(); } }),
    'a=7'
);
```

可以使用 `sort` 选项影响参数键的顺序：

```javascript
function alphabeticalSort(a, b) {
    return a.localeCompare(b);
}
assert.equal(qs.stringify({ a: 'c', z: 'y', b : 'f' }, { sort: alphabeticalSort }), 'a=c&b=f&z=y');
```

最后，可以使用 `filter` 选项来限制字符串化输出中将包含哪些键。
如果传递函数，将为每个键调用该函数以获取替换值。 相反，如果传递数组，它将用于选择属性和数组索引以进行字符串化：

```javascript
function filterFunc(prefix, value) {
    if (prefix == 'b') {
        // Return an `undefined` value to omit a property.
        return;
    }
    if (prefix == 'e[f]') {
        return value.getTime();
    }
    if (prefix == 'e[g][0]') {
        return value * 2;
    }
    return value;
}
qs.stringify({ a: 'b', c: 'd', e: { f: new Date(123), g: [2] } }, { filter: filterFunc });
// 'a=b&c=d&e[f]=123&e[g][0]=4'
qs.stringify({ a: 'b', c: 'd', e: 'f' }, { filter: ['a', 'e'] });
// 'a=b&e=f'
qs.stringify({ a: ['b', 'c', 'd'], e: 'f' }, { filter: ['a', 0, 2] });
// 'a[0]=b&a[2]=d'
```

### <a name="handling-of-null-values"></a>处理 `null` 值

默认情况下，`null` 值被视为空字符串：

```javascript
var withNull = qs.stringify({ a: null, b: '' });
assert.equal(withNull, 'a=&b=');
```

分析不区分具有等号和没有等号的参数。 两者都转换为空字符串。

```javascript
var equalsInsensitive = qs.parse('a&b=');
assert.deepEqual(equalsInsensitive, { a: '', b: '' });
```

若要区分 `null` 值和空字符串，请使用 `strictNullHandling` 标志。 在结果字符串中，`null` 值没有 `=` 符号：

```javascript
var strictNull = qs.stringify({ a: null, b: '' }, { strictNullHandling: true });
assert.equal(strictNull, 'a&b=');
```

若要将没有 `=` 的值分析回 `null`，请使用 `strictNullHandling` 标志：

```javascript
var parsedStrictNull = qs.parse('a&b=', { strictNullHandling: true });
assert.deepEqual(parsedStrictNull, { a: null, b: '' });
```

若要完全跳过具有 `null` 值的呈现键，请使用 `skipNulls` 标志：

```javascript
var nullsSkipped = qs.stringify({ a: 'b', c: null}, { skipNulls: true });
assert.equal(nullsSkipped, 'a=b');
```

如果要与旧系统通信，则可以使用 `charset` 选项切换到 `iso-8859-1`：

```javascript
var iso = qs.stringify({ æ: 'æ' }, { charset: 'iso-8859-1' });
assert.equal(iso, '%E6=%E6');
```

`iso-8859-1` 中不存在的字符将转换为数字实体，类似于浏览器执行的操作：

```javascript
var numeric = qs.stringify({ a: '☺' }, { charset: 'iso-8859-1' });
assert.equal(numeric, 'a=%26%239786%3B');
```

如果选中复选标记，则可以使用 `charsetSentinel` 选项通过包含具有正确编码的 `utf8=✓` 参数来宣布字符，类似于 Ruby on Rails 和其他程序在提交表单时执行的操作。

```javascript
var sentinel = qs.stringify({ a: '☺' }, { charsetSentinel: true });
assert.equal(sentinel, 'utf8=%E2%9C%93&a=%E2%98%BA');

var isoSentinel = qs.stringify({ a: 'æ' }, { charsetSentinel: true, charset: 'iso-8859-1' });
assert.equal(isoSentinel, 'utf8=%26%2310003%3B&a=%E6');
```

### <a name="dealing-with-special-character-sets"></a>处理特殊字符集

默认情况下，字符的编码和解码在 `utf-8` 中完成，并且还通过 `charset` 参数内置 `iso-8859-1` 支持。

如果要将查询字符串编码到其他字符集（即 [Shift JIS](https://en.wikipedia.org/wiki/Shift_JIS)），可以使用 [`qs-iconv`](https://github.com/martinheidegger/qs-iconv) 库：

```javascript
var encoder = require('qs-iconv/encoder')('shift_jis');
var shiftJISEncoded = qs.stringify({ a: 'こんにちは！' }, { encoder: encoder });
assert.equal(shiftJISEncoded, 'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I');
```

这也适用于解码查询字符串：

```javascript
var decoder = require('qs-iconv/decoder')('shift_jis');
var obj = qs.parse('a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I', { decoder: decoder });
assert.deepEqual(obj, { a: 'こんにちは！' });
```

### <a name="rfc-3986-and-rfc-1738-space-encoding"></a>RFC 3986 和 RFC 1738 空格编码

RFC3986 用作默认选项，并将“ ”编码为后向兼容的 %20。
同时，可以按照 RFC1738 字符串化输出，其中“ ”等于“+”。

```
assert.equal(qs.stringify({ a: 'b c' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC3986' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC1738' }), 'a=b+c');
```

## <a name="security"></a>安全性

如果有潜在的安全漏洞要报告，请发送电子邮件至 [@ljharb](https://github.com/ljharb) 或查看 https://tidelift.com/security 。

## <a name="qs-for-enterprise"></a>适用于企业的 qs

作为 Tidelift 订阅的一部分提供

qs 和其他数千个包的维护人员正在与 Tidelift 合作，为用于生成应用程序的开放源代码依赖项提供商业支持和维护。 节省时间、降低风险并改善代码运行状况，同时为所使用的确切依赖项的维护人员付费。 [了解详细信息。](https://tidelift.com/subscription/pkg/npm-qs?utm_source=npm-qs&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)

[1]: https://npmjs.org/package/qs
[2]: http://versionbadg.es/ljharb/qs.svg
[3]: https://api.travis-ci.org/ljharb/qs.svg
[4]: https://travis-ci.org/ljharb/qs
[5]: https://david-dm.org/ljharb/qs.svg
[6]: https://david-dm.org/ljharb/qs
[7]: https://david-dm.org/ljharb/qs/dev-status.svg
[8]: https://david-dm.org/ljharb/qs?type=dev
[9]: https://ci.testling.com/ljharb/qs.png
[10]: https://ci.testling.com/ljharb/qs
[11]: https://nodei.co/npm/qs.png?downloads=true&stars=true
[license-image]: http://img.shields.io/npm/l/qs.svg
[license-url]: LICENSE
[downloads-image]: http://img.shields.io/npm/dm/qs.svg
[downloads-url]: http://npm-stat.com/charts.html?package=qs
