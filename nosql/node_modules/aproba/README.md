---
ms.openlocfilehash: b8e00448fe7f8445c8e81302b03a852ee0f7e5cc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050829"
---
<a name="aproba"></a>aproba
======

一个极其轻量的函数参数验证程序

```
var validate = require("aproba")

function myfunc(a, b, c) {
  // `a` must be a string, `b` a number, `c` a function
  validate('SNF', arguments) // [a,b,c] is also valid
}

myfunc('test', 23, function () {}) // ok
myfunc(123, 23, function () {}) // type error
myfunc('test', 23) // missing arg error
myfunc('test', 23, function () {}, true) // too many args error

```

有效类型包括：

| type | description
| :--: | :----------
| *    | 匹配任何类型
| A    | `Array.isArray` 或 `arguments` 对象
| S    | typeof == 字符串
| N    | typeof == 数字
| F    | typeof == 函数
| O    | typeof == 既非类型 A 又非类型 E 的对象
| B    | typeof == 布尔值
| E    | `instanceof Error` 或 `null`（特殊：请参阅下文）
| Z    | == `null`

验证失败会引发三种异常类型之一，由 `EMISSINGARG`、`EINVALIDTYPE` 或 `ETOOMANYARGS` 的 `code` 属性区分。

如果传入无效类型，则会引发 `EUNKNOWNTYPE` 代码。

如果找到错误参数且不为 null，则剩余参数是可选的。  也就是说，如果为 `ESO`，那么就像在 `E|ESO|ZSO` 中使用一个非神奇的 `E`。

### <a name="but-i-have-optional-arguments"></a>但我有可选参数？！

可以提供多个签名并使用 `|` 符号进行分隔。
如果任何签名与参数匹配，则它们将被视为有效。

例如，假设你想要为 `fs.createWriteStream` 写入签名。  因此，其文档将对其进行描述：

```
fs.createWriteStream(path[, options])
```

这将是 `SO|S` 的签名。  也就是说，字符串和对象，或只是一个字符串。

现在，如果阅读完整的 `fs` 文档，你将看到实际路径也可以是缓冲区。  选项可以是字符串，即：
```
path <String> | <Buffer>
options <String> | <Object>
```

若要重现这种情况，必须完全枚举所有可能的组合，这意味着 `SO|SS|OO|OS|S|O` 的签名。  尴尬的是一个功能：它提醒你在执行此类操作时添加到 API 中的复杂性。


### <a name="browser-support"></a>浏览器支持

这没有依赖项，应该在浏览器中工作，不过你会有更嘈杂的堆栈跟踪。

### <a name="why-this-exists"></a>存在原因

我想要一个非常简单的参数验证程序。 需要执行两项操作：

1. 比断言更简洁易用

2. 不鼓励 DSL 的无限重复讨论

这就是为什么类型是由单个字符指定的，并且没有可选参数之类的内容。 

这不用于验证用户数据。 这具体涉及断言函数的接口。

如果需要更强大的验证，建议手动编写或看看其他地方。

