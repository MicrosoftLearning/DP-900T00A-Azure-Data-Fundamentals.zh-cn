---
ms.openlocfilehash: 0e4384a6edea7b3a580ffa5b32236b7f8b251834
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050650"
---
# <a name="combined-stream"></a>combined-stream

一个接一个地发出多个其他流的流。

注意：目前 `combined-stream` 仅支持流版本 1。 目前正在努力将此库切换到流版本 2。 欢迎任何帮助。 :)同时，可以浏览提供 streams2 支持并与 `combined-stream` 或多或少兼容的其他库。

- [combined-stream2](https://www.npmjs.com/package/combined-stream2):与 streams2 完全兼容的 combined-stream 模块的替代。

- [multistream](https://www.npmjs.com/package/multistream)：一个接一个地发出多个其他流的流。

## <a name="installation"></a>安装

``` bash
npm install combined-stream
```

## <a name="usage"></a>使用情况

下面是一个简单的示例，演示如何使用 combined-stream 将两个文件合并为一个：

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create();
combinedStream.append(fs.createReadStream('file1.txt'));
combinedStream.append(fs.createReadStream('file2.txt'));

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

虽然上面的示例效果很好，但它将暂停所有源流，直到需要它们。 如果不想让此情况发生，可以将 `pauseStreams` 设置为 `false`：

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create({pauseStreams: false});
combinedStream.append(fs.createReadStream('file1.txt'));
combinedStream.append(fs.createReadStream('file2.txt'));

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

但是，如果还没有所有源流，或者不想立即为其分配（文件描述符和内存等）资源，该怎么办？
在这种情况下，只需通过调用 `next()` 函数来提供一个回调，以提供流：

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create();
combinedStream.append(function(next) {
  next(fs.createReadStream('file1.txt'));
});
combinedStream.append(function(next) {
  next(fs.createReadStream('file2.txt'));
});

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

## <a name="api"></a>API

### <a name="combinedstreamcreateoptions"></a>CombinedStream.create([options])

返回新的合并流对象。 可用选项包括：

* `maxDataSize`
* `pauseStreams`

这些选项的效果如下所述。

### <a name="combinedstreampausestreams--true"></a>combinedStream.pauseStreams = `true`

是否对底层流应用回压。 如果设置为 `false`，则将永远不会暂停底层流。 如果设置为 `true`，底层流将在被追加以及 `delayedStream.pipe()` 想要进行限制时被立即暂停。

### <a name="combinedstreammaxdatasize--2--1024--1024"></a>combinedStream.maxDataSize = `2 * 1024 * 1024`

为所有源流缓冲的最大字节（或字符）数。
如果超过此值，`combinedStream` 则发出 `'error'` 事件。

### <a name="combinedstreamdatasize--0"></a>combinedStream.dataSize = `0`

当前由 `combinedStream` 缓冲的字节（或字符）数。

### <a name="combinedstreamappendstream"></a>combinedStream.append(stream)

将给定的 `stream` 追加到 combinedStream 对象。 如果 `pauseStreams` 设置为“true”，此流也将立即暂停。

`streams` 也可以是一个采用名为 `next` 的参数的函数。 `next` 是一个必须被调用才能提供 `next` 流的函数，请参阅上面的示例。

无论如何追加 `stream`，combined-stream 始终会向其附加 `'error'` 侦听器，因此无需手动执行此操作。

特殊情况：`stream` 也可以是字符串或缓冲区。

### <a name="combinedstreamwritedata"></a>combinedStream.write(data)

不应调用它，`combinedStream` 负责为你将追加的流管道输送到自身。

### <a name="combinedstreamresume"></a>combinedStream.resume()

导致 `combinedStream` 开始清空其管理的流。 该函数是幂等的，并且每次都会发出一个 `'resume'` 事件，该事件通常会发送到当前正在清空的流。

### <a name="combinedstreampause"></a>combinedStream.pause();

如果 `combinedStream.pauseStreams` 设置为 `false`，则不执行任何操作。
否则将发出 `'pause'` 事件，这会转到当前正在清空的流，因此你可以使用它来应用回压。

### <a name="combinedstreamend"></a>combinedStream.end();

将 `combinedStream.writable` 设置为 false 时，将发出 `'end'` 事件，并从队列中删除所有流。

### <a name="combinedstreamdestroy"></a>combinedStream.destroy();

与 `combinedStream.end()` 相同，只是它发出的是 `'close'` 事件而不是 `'end'`。

## <a name="license"></a>许可

combined-stream 根据 MIT 许可证获得许可。
