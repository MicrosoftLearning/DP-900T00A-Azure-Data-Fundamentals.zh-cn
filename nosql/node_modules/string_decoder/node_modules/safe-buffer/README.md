---
ms.openlocfilehash: 75916065970faa645bca603327ecbaea09afe12e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050549"
---
# <a name="safe-buffer-travistravis-imagetravis-url-npmnpm-imagenpm-url-downloadsdownloads-imagedownloads-url-javascript-style-guidestandard-imagestandard-url"></a>safe-buffer [![travis][travis-image]][travis-url] [![npm][npm-image]][npm-url] [![下载][downloads-image]][downloads-url] [![javascript 风格指南][standard-image]][standard-url]

[travis-image]: https://img.shields.io/travis/feross/safe-buffer/master.svg
[travis-url]: https://travis-ci.org/feross/safe-buffer
[npm-image]: https://img.shields.io/npm/v/safe-buffer.svg
[npm-url]: https://npmjs.org/package/safe-buffer
[downloads-image]: https://img.shields.io/npm/dm/safe-buffer.svg
[downloads-url]: https://npmjs.org/package/safe-buffer
[standard-image]: https://img.shields.io/badge/code_style-standard-brightgreen.svg
[standard-url]: https://standardjs.com

#### <a name="safer-nodejs-buffer-api"></a>更安全的 Node.js 缓冲区 API

在所有版本的 Node.js 中使用新的 Node.js 缓冲区 API（`Buffer.from`、`Buffer.alloc`、`Buffer.allocUnsafe`、`Buffer.allocUnsafeSlow`）。

**在可用时使用内置实现。**

## <a name="install"></a>安装

```
npm install safe-buffer
```

## <a name="usage"></a>usage

此包的目标是为 node.js `Buffer` 提供安全替换。

它是 `Buffer` 的直接替换项。 可以通过在 node.js 模块的顶部添加一行 `require` 来使用它：

```js
var Buffer = require('safe-buffer').Buffer

// Existing buffer code will continue to work without issues:

new Buffer('hey', 'utf8')
new Buffer([1, 2, 3], 'utf8')
new Buffer(obj)
new Buffer(16) // create an uninitialized buffer (potentially unsafe)

// But you can use these new explicit APIs to make clear what you want:

Buffer.from('hey', 'utf8') // convert from many types to a Buffer
Buffer.alloc(16) // create a zero-filled buffer (safe)
Buffer.allocUnsafe(16) // create an uninitialized buffer (potentially unsafe)
```

## <a name="api"></a>api

### <a name="class-method-bufferfromarray"></a>类方法：Buffer.from(array)
<!-- YAML
added: v3.0.0
-->

* `array` {Array}

使用八进制 `array` 分配一个新的 `Buffer`。

```js
const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
  // creates a new Buffer containing ASCII bytes
  // ['b','u','f','f','e','r']
```

如果 `array` 不是 `Array`，则会引发 `TypeError`。

### <a name="class-method-bufferfromarraybuffer-byteoffset-length"></a>类方法：Buffer.from(arrayBuffer[, byteOffset[, length]])
<!-- YAML
added: v5.10.0
-->

* `arrayBuffer` {ArrayBuffer} `TypedArray` 或 `new ArrayBuffer()` 的 `.buffer` 属性
* `byteOffset` {Number} 默认值：`0`
* `length` {Number} 默认值：`arrayBuffer.length - byteOffset`

当传递对 `TypedArray` 实例的 `.buffer` 属性的引用时，新创建的 `Buffer` 将与 TypedArray 共享相同的分配内存。

```js
const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf = Buffer.from(arr.buffer); // shares the memory with arr;

console.log(buf);
  // Prints: <Buffer 88 13 a0 0f>

// changing the TypedArray changes the Buffer also
arr[1] = 6000;

console.log(buf);
  // Prints: <Buffer 88 13 70 17>
```

可选的 `byteOffset` 和 `length` 参数指定 `arrayBuffer` 内将由 `Buffer` 共享的内存范围。

```js
const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);
console.log(buf.length);
  // Prints: 2
```

如果 `arrayBuffer` 不是 `ArrayBuffer`，则会引发 `TypeError`。

### <a name="class-method-bufferfrombuffer"></a>类方法：Buffer.from(buffer)
<!-- YAML
added: v3.0.0
-->

* `buffer` {Buffer}

将传递的 `buffer` 数据复制到新的 `Buffer` 实例。

```js
const buf1 = Buffer.from('buffer');
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;
console.log(buf1.toString());
  // 'auffer'
console.log(buf2.toString());
  // 'buffer' (copy is not changed)
```

如果 `buffer` 不是 `Buffer`，则会引发 `TypeError`。

### <a name="class-method-bufferfromstr-encoding"></a>类方法：Buffer.from(str[, encoding])
<!-- YAML
added: v5.10.0
-->

* `str` {String} 要编码的字符串。
* `encoding` {String} 要使用的编码，默认值：`'utf8'`

创建包含给定 JavaScript 字符串 `str` 的新 `Buffer`。 如果提供，则 `encoding` 参数将标识字符编码。
如未提供，则 `encoding` 默认为 `'utf8'`。

```js
const buf1 = Buffer.from('this is a tést');
console.log(buf1.toString());
  // prints: this is a tést
console.log(buf1.toString('ascii'));
  // prints: this is a tC)st

const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
console.log(buf2.toString());
  // prints: this is a tést
```

如果 `str` 不是字符串，则会引发 `TypeError`。

### <a name="class-method-bufferallocsize-fill-encoding"></a>类方法：Buffer.alloc(size[, fill[, encoding]])
<!-- YAML
added: v5.10.0
-->

* `size` {Number}
* `fill` {Value} 默认值：`undefined`
* `encoding` {String} 默认值：`utf8`

分配 `size` 字节的新 `Buffer`。 如果 `fill` 是 `undefined`，则 `Buffer` 为零填充。

```js
const buf = Buffer.alloc(5);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

`size` 必须小于或等于 `require('buffer').kMaxLength` 的值（在 64 位架构上，`kMaxLength` 是 `(2^31)-1`）。 否则，将会引发 [`RangeError`][]。 如果指定 `size` 小于或等于 0，那么将会创建零长度缓冲区。

如果指定 `fill`，则通过调用 `buf.fill(fill)` 来初始化分配的 `Buffer`。 有关详细信息，请参阅 [`buf.fill()`][]。

```js
const buf = Buffer.alloc(5, 'a');
console.log(buf);
  // <Buffer 61 61 61 61 61>
```

如果同时指定 `fill` 和 `encoding`，则分配的 `Buffer` 将通过调用 `buf.fill(fill, encoding)` 进行初始化。 例如：

```js
const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
console.log(buf);
  // <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
```

调用 `Buffer.alloc(size)` 明显要比替代 `Buffer.allocUnsafe(size)` 慢得多，但可以确保新创建的 `Buffer` 实例内容永远不会包含敏感数据。

如果 `size` 不是数值，则会引发 `TypeError`。

### <a name="class-method-bufferallocunsafesize"></a>类方法：Buffer.allocUnsafe(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

分配 `size` 字节的新的非零填充 `Buffer`。  `size` 必须小于或等于 `require('buffer').kMaxLength` 的值（在 64 位架构上，`kMaxLength` 是 `(2^31)-1`）。 否则，将会引发 [`RangeError`][]。 如果指定 `size` 小于或等于 0，那么将会创建零长度缓冲区。

以这种方式创建的 `Buffer` 实例的底层内存未进行初始化。 新创建的 `Buffer` 的内容未知，可能包含敏感数据。 使用 [`buf.fill(0)`][] 将此类 `Buffer` 实例初始化为零。

```js
const buf = Buffer.allocUnsafe(5);
console.log(buf);
  // <Buffer 78 e0 82 02 01>
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

如果 `size` 不是数值，则会引发 `TypeError`。

请注意，`Buffer` 模块预分配了一个大小为 `Buffer.poolSize` 的内部 `Buffer` 实例，该实例在仅当 `size` 小于或等于 `Buffer.poolSize >> 1`（`Buffer.poolSize` 的下限除以二）时，才用作快速分配使用 `Buffer.allocUnsafe(size)`（以及已弃用的 `new Buffer(size)` 构造函数）创建的新 `Buffer` 实例的池。 `Buffer.poolSize` 的默认值为 `8192`，但可以修改。

使用此预先分配的内部内存池是调用 `Buffer.alloc(size, fill)` 与调用 `Buffer.allocUnsafe(size).fill(fill)` 之间的关键区别。具体来说，如果 `size` 小于或等于 `Buffer.poolSize` 的一半，`Buffer.alloc(size, fill)` 将永远不会使用内部缓冲池，而 `Buffer.allocUnsafe(size).fill(fill)` 则会使用内部缓冲池 。 这种差异很微妙，但在应用程序需要 `Buffer.allocUnsafe(size)` 提供的额外性能时可能很重要。

### <a name="class-method-bufferallocunsafeslowsize"></a>类方法：Buffer.allocUnsafeSlow(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

分配 `size` 字节的一个新的非零填充且非池化的 `Buffer`。  `size` 必须小于或等于 `require('buffer').kMaxLength` 的值（在 64 位架构上，`kMaxLength` 是 `(2^31)-1`）。 否则，将会引发 [`RangeError`][]。 如果指定 `size` 小于或等于 0，那么将会创建零长度缓冲区。

以这种方式创建的 `Buffer` 实例的底层内存未进行初始化。 新创建的 `Buffer` 的内容未知，可能包含敏感数据。 使用 [`buf.fill(0)`][] 将此类 `Buffer` 实例初始化为零。

使用 `Buffer.allocUnsafe()` 分配新的 `Buffer` 实例时，默认情况下，小于 4KB 的分配是从单个预分配的 `Buffer` 中切分而来的。 这样应用程序就可以避免创建大量单独分配的缓冲区的垃圾回收开销。 此方法通过消除跟踪和清理尽可能多的 `Persistent` 对象的需求来提高性能和内存使用率。

但是，在开发人员可能需要在不确定的时间内从池中保留一小块内存的情况下，使用 `Buffer.allocUnsafeSlow()` 创建一个未池化的缓冲区实例然后复制相关位可能比较合适。

```js
// need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () => {
  const data = socket.read();
  // allocate for retained data
  const sb = Buffer.allocUnsafeSlow(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});
```

只有在开发人员发现应用程序中存在不适当的内存保留后，才应将使用 `Buffer.allocUnsafeSlow()` 作为最后的手段。

如果 `size` 不是数值，则会引发 `TypeError`。

### <a name="all-the-rest"></a>其余所有

其余 `Buffer` API 与 node.js 中的完全相同。
[请参阅文档](https://nodejs.org/api/buffer.html)。


## <a name="related-links"></a>相关链接

- [Node.js 问题：Buffer(number) 不安全](https://github.com/nodejs/node/issues/4660)
- [Node.js 增强方案：Buffer.from/Buffer.alloc/Buffer.zalloc/Buffer() 软弃用](https://github.com/nodejs/node-eps/pull/4)

## <a name="why-is-buffer-unsafe"></a>为什么 `Buffer` 不安全？

目前，node.js `Buffer` 构造函数重载以处理许多不同的参数类型，如 `String`、`Array`、`Object`、`TypedArrayView`（`Uint8Array` 等）、`ArrayBuffer` 以及 `Number`。

为方便使用，API 经过优化：你可以向其抛出任何类型，它会尝试执行所需的操作。

由于 Buffer 构造函数非常强大，所以经常会看到这样的代码：

```js
// Convert UTF-8 strings to hex
function toHex (str) {
  return new Buffer(str).toString('hex')
}
```

***但是，如果使用 `Number` 参数调用 `toHex` 会发生什么？***

### <a name="remote-memory-disclosure"></a>远程内存泄漏

如果攻击者可以让程序使用 `Number` 参数调用 `Buffer` 构造函数，那么他们可以使其从 node.js 进程分配未初始化的内存。
这可能会泄露 TLS 私钥、用户数据或数据库密码。

当 `Buffer` 构造函数传递 `Number` 参数时，它会返回一个指定 `size` 的“未初始化的”内存块。 创建这样的 `Buffer` 时，“必须”先覆盖内容，然后再将其返回给用户。

从 [node.js 文档中](https://nodejs.org/api/buffer.html#buffer_new_buffer_size)：

> `new Buffer(size)`
>
> - `size` 数字
>
> 以这种方式创建的 `Buffer` 实例的底层内存未进行初始化。
> 新创建的 `Buffer` 内容未知，可能包含敏感数据。 使用 `buf.fill(0)` 将 Buffer 初始化为零。

（强调自己的内容。）

每当程序员打算创建未初始化的 `Buffer` 时，通常会看到如下代码：

```js
var buf = new Buffer(16)

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="would-this-ever-be-a-problem-in-real-code"></a>这是否是实际代码中存在的问题？

是的。 忘记检查动态类型语言（如 JavaScript）中变量的类型是非常常见的。

通常，假设错误类型会导致程序因未捕获的异常而崩溃。 但是，忘记检查 `Buffer` 构造函数的参数类型的失败模式更具灾难性。

下面是一个易受攻击的服务示例，该服务采用 JSON 有效负载并将其转换为十六进制：

```js
// Take a JSON payload {str: "some string"} and convert it to hex
var server = http.createServer(function (req, res) {
  var data = ''
  req.setEncoding('utf8')
  req.on('data', function (chunk) {
    data += chunk
  })
  req.on('end', function () {
    var body = JSON.parse(data)
    res.end(new Buffer(body.str).toString('hex'))
  })
})

server.listen(8080)
```

在此示例中，http 客户端只需发送：

```json
{
  "str": 1000
}
```

它将从服务器中返回 1,000 字节的未初始化内存。

这是一个非常严重的 bug。 其严重程度类似于允许远程攻击者泄露 OpenSSL 进程内存的 [Heartbleed bug](http://heartbleed.com/)。


### <a name="which-real-world-packages-were-vulnerable"></a>哪些真实包易受攻击？

#### [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht)

[Mathias Buus](https://github.com/mafintosh) 和我 ([Feross Aboukhadijeh](http://feross.org/)) 在我们的其中一个包中发现了此问题，[`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht)。 该 bug 允许 Internet 上的任何人向 `bittorrent-dht` 用户发送一系列消息，让他们从 node.js 进程中一次显示 20 个字节的未初始化内存。

下面是修复该问题所[提交的内容](https://github.com/feross/bittorrent-dht/commit/6c7da04025d5633699800a99ec3fbadf70ad35b8)。 我们发布了新的修正版本，创建了[节点安全项目披露](https://nodesecurity.io/advisories/68)，并在 npm 上弃用了所有易受攻击的版本，因此用户将收到升级到新版本的警告。

#### [`ws`](https://www.npmjs.com/package/ws)

这让我们想知道是否有其他易受攻击的包。 果然，我们很快在 [`ws`](https://www.npmjs.com/package/ws)（node.js 中最流行的 WebSocket 实现）中发现了同样的问题。

如果按预期使用 `Number` 参数而不是 `String` 或 `Buffer` 调用某些 API，则未初始化的服务器内存将被泄露给远程对等方。

这些是易受攻击的方法：

```js
socket.send(number)
socket.ping(number)
socket.pong(number)
```

下面是具有一些回显功能的易受攻击的套接字服务器：

```js
server.on('connection', function (socket) {
  socket.on('message', function (message) {
    message = JSON.parse(message)
    if (message.type === 'echo') {
      socket.send(message.data) // send back the user's message
    }
  })
})
```

在服务器上调用 `socket.send(number)`，将公开服务器内存。

该问题在[此版本](https://github.com/websockets/ws/releases/tag/1.0.1)中得到修复，并提供了更详细的说明。 [Arnout Kazemier](https://github.com/3rd-Eden) 有快速解决的办法。 请参阅[节点安全项目披露](https://nodesecurity.io/advisories/67)。


### <a name="whats-the-solution"></a>解决方案是什么？

重要的是 node.js 提供了一种快速获取内存的方法，否则性能关键型应用程序会不必要地变慢很多。

但是我们需要一种更好的方式来表达我们作为程序员的意图。 **当我们需要未初始化的内存时，应显式请求。**

不应将敏感功能打包到易于开发人员使用的 API 中，这样的 API 会宽泛地接受许多不同类型的功能。 这种类型的 API 鼓励在不仔细检查类型的情况下随意传入变量。

#### <a name="a-new-api-bufferallocunsafenumber"></a>新的 API：`Buffer.allocUnsafe(number)`

使用未初始化内存创建缓冲区的功能应该是另一个 API 的一部分。 建议使用 `Buffer.allocUnsafe(number)`。 这样，它就不是 API 的一部分，该 API 经常获取传递给它的各种不同类型的用户输入。

```js
var buf = Buffer.allocUnsafe(16) // careful, uninitialized memory!

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="how-do-we-fix-nodejs-core"></a>如何修复 node.js 核心？

[向 node.js 核心（合并为 `semver-major`）发送 PR](https://github.com/nodejs/node/pull/4514)，它可以防御一种情况：

```js
var str = 16
new Buffer(str, 'utf8')
```

在这种情况下，暗示程序员打算将第一个参数作为字符串，因为他们将编码作为第二个参数进行传递。 目前，node.js 会在 `new Buffer(number, encoding)` 的情况下分配未初始化的内存，这可能不是程序员的本意。

但这只是部分解决方案，因为如果程序员（在没有 `encoding` 参数的情况下）执行 `new Buffer(variable)`，则无法知道他们的意图。 如果 `variable` 有时是数字，则有时将返回未初始化的内存。

### <a name="whats-the-real-long-term-fix"></a>真正的长期解决方案是什么？

当我们需要未初始化的内存时，可以弃用和删除 `new Buffer(number)` 并使用 `Buffer.allocUnsafe(number)`。 但这会破坏 1000 个包。

~~我们相信最好的解决方案是：~~

~~1.更改 `new Buffer(number)` 以返回安全、清零的内存~~

~~2.创建用于创建未初始化缓冲区的新 API。建议使用：`Buffer.allocUnsafe(number)`~~

#### <a name="update"></a>更新

现在支持添加三个新 API：

- `Buffer.from(value)` - 从任何类型转换为缓冲区
- `Buffer.alloc(size)` - 创建以零填充的缓冲区
- `Buffer.allocUnsafe(size)` - 创建具有给定大小的未初始化缓冲区

这解决了影响 `ws` 和 `bittorrent-dht` 的核心问题，即 `Buffer(variable)` 被欺骗采用数字参数。

这样一来，现有代码继续正常运行，并最大限度地减小对 npm 生态系统的影响。 随着时间的推移，npm 维护人员可以迁移性能关键型代码以使用 `Buffer.allocUnsafe(number)`，而不是 `new Buffer(number)`。


### <a name="conclusion"></a>结论

我们认为现在的 `Buffer` API 存在严重的设计问题。 它通过将高风险功能放入具有友好“开发人员人体工程学”的便捷 API 来推广不安全的软件。

这不仅仅是一个理论练习，因为我们在一些最受欢迎的 npm 包中发现了这个问题。

幸运的是，现在有一个简单的解决办法。 使用 `safe-buffer` 替换 `buffer`。

```js
var Buffer = require('safe-buffer').Buffer
```

最后，我们希望 node.js 核心可以切换到这种新的、更安全的行为。 我们相信对生态系统的影响将是最小的，因为这不是一个中断性变更。
维护良好的流行包将被快速更新为使用 `Buffer.alloc`，而不安全的旧包会神奇地免受这种攻击途径的影响。


## <a name="links"></a>链接

- [Node.js PR：缓冲区：如果传递 length 和 enc，则引发](https://github.com/nodejs/node/pull/4514)
- [`ws` 的节点安全项目披露](https://nodesecurity.io/advisories/67)
- [`bittorrent-dht` 的节点安全项目披露](https://nodesecurity.io/advisories/68)


## <a name="credit"></a>致谢人员

`bittorrent-dht`（[披露信息](https://nodesecurity.io/advisories/68)）和 `ws`（[披露信息](https://nodesecurity.io/advisories/67)）中的原始问题是由 [Mathias Buus](https://github.com/mafintosh) 和 [Feross Aboukhadijeh](http://feross.org/) 发现。

感谢 [Adam Baldwin](https://github.com/evilpacket) 帮助披露这些问题，以及运行[节点安全项目](https://nodesecurity.io/)所做的工作。

感谢 [John Hiesey](https://github.com/jhiesey) 校对本 README 并审核代码。


## <a name="license"></a>license

MIT。 版权所有 (C) [Feross Aboukhadijeh](http://feross.org)
